<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[黑苹果安装 联想S410 i5-4210 HD4400]]></title>
    <url>%2F2020%2F04%2F28%2F%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%AE%89%E8%A3%85%20%E8%81%94%E6%83%B3S410%20i5-4210%20HD4400%2F</url>
    <content type="text"><![CDATA[安装前准备工作调整硬盘如果硬盘本身就是gpt/guid模式，就不需要这步 使用DiskGenius更改硬盘模式会销毁整个硬盘数据，一定要备份整个硬盘重要数据；除DiskGenius外，windows官网还提供了MBR2GPT工具可以无损更改硬盘模式，我在这里使用的是DiskGenius 制作老毛桃U盘启动盘 访问 老毛桃官网，选择”下载UEFI版” 准备一个大于4G的U盘，制作启动盘，选项默认即可 制作完成 制作UEFI引导的w10启动盘 访问 I Tell you 选择“操作系统” –&gt; 选择你喜欢的w10系统 –&gt; 查看镜像详细信息，复制ed2k链接 下载镜像 可以使用迅雷 如果有百度云盘会员，可以先离线下载，然后再下载 下载 rufus，rufus相较于UltraISO很容易制作uefi引导的启动盘，除此之外，安装linux系统大多也是使用rufus 准别另一个U盘，调整参数，制作启动盘 制作完成 删除硬盘分区 重要的是事情说三遍：一定备份、一定备份、一定备份 使用老毛桃启动盘，重启系统，F12（根据自己机型）选择U盘启动 启动 DiskGenius硬盘分区工具 选中整块硬盘 –&gt; 右键 –&gt; 删除所有分区 更改硬盘模式为gpt/guid 选中整块硬盘 –&gt; 右键 –&gt; 转换分区表类型为GUID模式 新建EFI/ESP分区 选中硬盘空闲区域 –&gt; 新建分区/新建ESP分区 –&gt; 勾选“建立ESP分区”，分区大小至少400M，不能太小，否则后续安装可能失败 –&gt; 一路确定 新建主分区 这里我分配两个主分区，分别是w10的C盘和D盘，同时根据自己需求，预留合适大小的空闲空间，来安装MAC系统 选中硬盘空闲区域 –&gt; 新建分区 –&gt; 勾选”主磁盘分区” –&gt; 填写分区大小 –&gt; 确定 安装w10+uefi如果硬盘本身就是gpt/guid模式，并且windows系统本身就是uefi启动的，就不需要这步 安装 使用刚刚制作的w10启动盘，重启安装 按 Fn+F2 进入BIOS（因电脑型号而异），在 Boot 选项中更改 Boot Mode 为 “UEFI” 后保存退出 接下来的步骤比较无脑，将新建的第一个主分区当作系统盘即可，这里不再赘述 激活windows 关闭w10自带杀毒工具的实时保护 下载 激活工具 一键式激活 如果激活成功，请忽略该步骤 针对windows企业版，与教育版与专业版的激活方式不同，上述工具激活不了企业版 下载 Windows全激活工具 选择一种激活方式，这里推荐第一种 新建RAW分区RAW分区将用来安装MAC系统，根据自己需求选择合适大小 右键“此电脑” –&gt; 管理 –&gt; 磁盘管理 –&gt; 选择预留的空闲空间 右键空闲空间 –&gt; 新建简单卷 –&gt; 选择“不分配驱动器号或驱动器路径” –&gt; 下一步 选择“不要格式化这个卷” –&gt; 下一步 完成 准备安装黑苹果需要的镜像、工具、引导镜像新手推荐选择 High Sierra 10.13.6，这个比较容易安装，也比较稳定 我选择的是 Majave 10.14.6，clover版本是5027，链接: https://pan.baidu.com/s/18lt2TUwYbrXC9Vg4ov8mCg 提取码: mprs 此外，还有其他版本的镜像可供选择 High Sierra 10.13.6, clover 4596，链接: https://pan.baidu.com/s/19-Lk3lntmRChEwezfwvdcg 提取码: z5hf Sierra 10.12.6, clover 4123，链接: https://pan.baidu.com/s/1_-bwAJ3zp-KiC4TxUUiKyw 提取码: 3ht7 Catalina 10.15.4, clover 5107，链接: https://pan.baidu.com/s/1iDrvhZZojv5WZsQnysULKQ 提取码: k5bv 工具链接: https://pan.baidu.com/s/1jfAtjMfutg9NjZclHhZr9w 提取码: r3ia 在windows系统用到的工具：TransMAC，DiskGenius，EasyUEFI 在苹果系统中用到的工具：Clover Configurator等 引导安装黑苹果最关键的一步，就是找到适合自己机型的EFI 这里是EFI机型大全，链接: https://pan.baidu.com/s/1jL7shH5joZxqYxaiE5uhKA 提取码: aujw 可以根据自己的机型，选择合适的EFI 比如自己的机型是 联想S410，查找 “联想” –&gt; S410就行 不过这种方法找到的EFI，自己试过后都没有效果，应该是因为自己这台电脑的主板烧过，换了主板，处理器更换了 此外，还可以根据处理器与显卡查找 右键此电脑 –&gt; 属性查看自己的处理器属性，我的是 intel core i5-4210U 右键此电脑 –&gt; 属性 –&gt; 设备管理器 –&gt; 显示适配器查看自己的显卡型号，我的是 intel HD Graphics Family 只能查看到自己的显卡是 intel系列的，不能查看具体的型号，比如 intel HD 6000；由于我的显卡是核芯显卡，也就是说显卡是集成在处理器上的，可以通过官网查看处理器i5-4210U参数，获取显卡具体型号 访问 https://www.intel.cn/content/www/cn/zh/support/detect.html，扫描自己的系统 搜索 “i5-4210U” 可以看到，我的显卡是 intel HD 4400 于是我选择了 “联想 E40-70 i5 4210U HD4400” 经过测试，这个EFI完全可以适配这台电脑 安装时 EFI 选取不需要那么严苛，声卡、网卡等这些可以安装黑苹果完成后优化，安装黑苹果时着重注意的还是处理器与显卡是否能够驱动 怎么选取EFI就先讲到这里，由于自己手中的电脑是笔记本，所以台式机又有些不一样；如果是AMD的处理器，那么使用的系统镜像又不一样；还有，自己的显卡是核芯显卡，那么独立显卡也会有些不同，多爬爬教程，或者加入一些群聊，请教那些大佬 安装黑苹果制作黑苹果系统启动盘使用TransMac写入镜像 以管理员方式启动 TransMac 准备一个U盘（如果安装10.15系统，最少需要16G），这里我是用的是刚刚的 w10 安装盘 右键U盘，选择”Format Disk for Mac”，然后一路 “OK” 右键U盘，选择”Restore with Disk Image”，选取下载的系统镜像 等待写入完成 使用DiskGenius更改EFI 以管理员方式启动 DiskGenius 选中U盘下EFI分区下的EFI文件夹 右键 CLOVER文件夹 –&gt; 强制删除文件 在适配自己机型的EFI文件夹中，复制 CLVOER文件夹 使用ctrl+v，复制到U盘下的EFI分区中 黑苹果启动盘制作完成 安装 Mojave将系统安装到硬盘 插入黑苹果启动盘，重启电脑 按 Fn+F2 进入BIOS（因电脑型号而异），在 Security 选项中关闭 “Secure Boot”，不关闭的话，无法安装 Linux与黑苹果 按 Fn+F12 选择启动项（因电脑型号而异），这里选择 “EFI USB Device” 选择 “Boot macOS install from install macOS Mojave” 等待进度条 抹掉磁盘时一定要选择正确，否则数据不可找回 进度条完成后，进入到系统，选择”磁盘工具” 选中我们刚刚为黑苹果新建的RAW分区 –&gt; 抹掉 –&gt; 输入名称 “MAC” –&gt; 选择格式 “APFS” –&gt; 点击 “抹掉” –&gt; 成功后退出 选择 “安装 macOS” 继续 同意 选中刚刚我们抹掉的磁盘 “MAC” 等待安装完成 从硬盘安装系统 在将系统安装到硬盘后会自动重启，在引导界面，选择 “Boot macOS from MAC” 等待几分钟 安装成功后，系统会自动重启，在引导界面，仍然选择 “Boot macOS from MAC”，第一次启动会比较慢，等几分钟后，出现系统设置界面，以下是一些设置，其他默认即可 设置键盘 先不连接网络 创建账户 大功告成 设置引导这部分的主要目的是，拔下U盘后，能够启动到 Mac 将引导拷贝到 ESP 分区 找到你刚刚下载的 EFI文件夹，复制其中的 CLOVER文件夹 使用 DiskGenius，粘贴到 ESP 分区下的 EFI 文件夹中 添加启动项 管理员方式启动 Hasleo EasyUEFI 选择 “管理EFI启动项” 选择 “创建新项” 配置启动项 选择 “浏览文件” 确定后添加完成 调整启动项顺序，让我们刚刚添加的移动到第一个，使其优先启动 重启电脑 问题列表安装 macOS 时提示 “这个安装 macOS Mojave应用程序副本已损坏，不能用来安装 macOS” 原因这是因为苹果于 2016.02.14 更换证书导致，系统日期更改到这个时间之前即可 解决 断网启动（如果没连接到网络，则不需要） 打开 “实用工具” –&gt; “终端” 输入: date 102723252015.06 退出终端，重新选择 “安装 macOS”]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库程序设计笔记]]></title>
    <url>%2F2020%2F04%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[第一单元第一课时 空值是不确定的值，排序时位置不定 123SELECT mgrFROM empGROUP BY mgr NULLS FIRST oracle 用户 scott/tiger sys 用户权限最高，可以启动关闭数据库 system 用户权限最二高 oracle 数值函数，在其他数据库中不一定好用 ROUND(value, pricision) 四舍五入 123456SELECT round(45.926, 2) -- 45.93FROM dual-- round(45.926, 0) -- 46-- round(45.926, -1) -- 50，十位-- round(45.926, -2) -- 100，百位 TRUNC(value, pricision) 截取 12SELECT trunc(45.926, -2) -- 0FROM dual MOD(被除数, 除数) 取余数 12SELECT mod(1600, 300) -- 100FROM dual 第二课时 oracle 字符函数 UPPER, LOWER, INITCAP1234-- oracle 大小写敏感，sqlserver 大小写不敏感SELECT enameFROM empWHERE lower(ename) = 'king'; – INITCAP 首字母大写，其他字母小写SELECT initcap(‘aBc dEF’) – Abc DefFROM dual 1234567891011* LENGTH```sqlSELECT length(&apos;汉字&apos;) -- 2，字FROM dual-- 多字节文字使用 lengthbSELECT lengthb(&apos;汉字&apos;) -- 4，字节FROM dual LTRIM, RIRIM 123456SELECT length(TRIM(' R F ')) -- 3FROM dual-- 去掉指定字符SELECT length(TRIM('m' FROM 'mmrmfm')) -- 3，rmfFROM dual SUBSTR 12345SELECT substr('abcd', 2) -- bcdFROM dual;SELECT substr('abcd', 2, 1) -- bFROM dual; INSTR 1234567891011-- 第一次出现SELECT instr('abcdabc', 'a') -- 1FROM dual;-- 从 1开始查找SELECT instr('abcdabc', 'c', 1) -- 3FROM dual;-- 查找第二个cSELECT instr('abcdabc', 'c', 1, 2) -- 7FROM dual; LPAD、RPAD 1234lpad(salary, 10, '*') -- *****24000rpad(salary, 10, '*') -- 24000*****lpad('*', 3, '*') -- *** 就是三个，没错rpad('*', 3, '*') -- *** concat(str1, str2) 只能连接两个字符， || 能连接多个 日期格式 默认格式: DD-MON-RR，如1982-01-01 –&gt; 01-1月-82 / 01-JAN-82 123SELECT hiredateFROM empWHERE hiredate &lt; '01-1月-82' 日期运算 日期 +- num 123SELECT SYSDATE-1, SYSDATE, SYSDATE+1FROM dual;-- 03-MAR-20 04-MAR-20 05-MAR-20 日期 - 日期 12SELECT (SYSDATE+1) - SYSDATE -- 1FROM dual; date + number/24 Adds a number of hours to a date 日期 - 字符串 123-- 日期不能直接减字符串SELECT (SYSDATE - to_date('01-JAN-00')) / 7 -- 1052.59819FROM dual; 第三课时 日期函数 ADD_MONTHS 日期 + 月 12SELECT add_months(to_date('2007-10-31', 'yyyy-mm-dd'), 1) -- 30-NOV-07FROM dual; LAST_DAY 月的最后一天 12SELECT last_day(SYSDATE) -- 31-MAR-20FROM dual; MONTHS_BETWEEN 两个日期相差多少个月 12SELECT months_between(SYSDATE, to_date('03/02/1986', 'MM/DD/YYYY')) -- 408.070879FROM dual; NEXT_DAY 12345SELECT next_day(SYSDATE, 'Monday') -- 09-MAR-20FROM dual;SELECT next_day(SYSDATE, 2) -- 2表示星期的第二天, 星期一: 09-MAR-20FROM dual; round round date trunc truncate date 转换函数 隐式转换 12345SELECT '1' + '2' -- 3FROM dual;SELECT 1 || 2 -- 12FROM dual; 显示转换 to_date 123456789101112SELECT hiredateFROM empWHERE hiredate &lt; to_date('81-01-01', 'rr-mm-dd')/* yy 与 rr 的区别 yy 是当前年的世纪 rr 是离当前年比较近的世纪 比如，当前年2001，日期27-OCT-95 rr：1995 yy: 2095 千年虫：2000、2038*/ to_char 转换日期 123456789101112131415161718192021select to_char(SYSDATE, 'Year-month-dd') -- Twently Twently-2月-25from dual;/* 日期格式 'yy-mm-d' d 表示这周的第几天 'yy-mm-ddd' ddd 表示年的第几天 'dd' 'yy' yyyy 2020 Year Twenty Twenty YEAR TWENTY TWENTY MM 03 Month 3月 Mon 月份缩写（3个字符） DAY 星期几 DY 星期几的缩写（3个字符） DD 22 HH24:MI:SS AM 15:45:32 PM DD "of" MONTH 22 of OCTOBER ddspth fourteenth*/ 转换数字 12345678select to_char(sql, '999999.99') -- 9表示数字，尽量多，不可以少from emp/* 数字格式 99999.99 不知道可以多写几位 99999.99$ / $99999.99 结果：$800.00 99999.99l l表示当地货币符号，800.00¥ l99999.99 结果：¥800.00*/ to_number，oracle中只有数字符串才能转换为数，所以’a’不能转为数 months_between，会隐式转换12select months_between(SYSDATE, '01-2月-00')from dual; 其他函数 NVL(input, default) 如果input为空，则用default代替 123456SELECT ename, sal, comm, sal*12 + nvl(comm, 0) + 10000FROM emp -- 保持数据类型一致SELECT comm, nvl(to_char(comm), 'no comm') -- 'no comm' 不能转为数字，所以将comm 转为字符串FROM emp NVL2(input, value1, value2) 如果input为空，返回value2, 如果input不为空，返回value1 value1 和 value2 数据类型需要一致 nullif(exp1, exp2) exp1 与 exp2相等时，返回null，否则返回exp1 coalesce(exp1, exp2, exp3, …) 返回第一个不是null的值 decode(input, search1, result1, search2, result2, …, [default]) 1234 -- 按星期几排序 select to_char(hire_date, 'Day') AS DAY from employeesorder by decode(DAY, '星期一', 1, '星期二', 2, '星期三', 3, '星期四', 4, '星期五', 5, '星期六', 6, '星期日', 7); case 表达式 12345678select job_id, case job_id when 'AD_PRES' THEN 'A' when 'ST_MAN' THEN 'B' when 'IT_PROG' THEN 'C' when 'SA_REP' THEN 'D' when 'ST_CLERK' THEN 'E' ELSE '0' END Grade -- 这里的'0'类型需要和'A'类型保持一致，即字符型from employees; 第四课时 sqlplus 12345678910111213141516171819202122sqlplus /nolog # /nolog 不能有空格sql&gt; conn / as sysdba # / 两边分别是用户/口令，可以省略sql&gt; show user # 显示用户# sql 语句需要分号结束sql&gt; alter user scott account unlock; # 解锁sql&gt; alter user scott identified by tiger; #更改口令sql&gt; select * from tab; # 查看当前用户下的表sql&gt; desc emp # 查看emp表的字段sql&gt; conn / as sysdba # 切换到sys用户sql&gt; shutdown immediate # 关闭数据库sql&gt; startup force # 启动数据库sql&gt; show errors # 查看目前程序有哪些错误 PLSQLDeveloper 图形化 TOAD 图形化 第二单元第一课时 PL/SQL 概述SQL PL IBMT-SQL 微软PL/SQL oracle sql 类型 select dml: insert update delete merge 事务：commit, callback, savepoint ddl: create, alter, drop, truncate, rename dcl: grant, revoke PL/SQL 优点： 改善性能 可重用性 模块化 PL/SQL 类型 匿名块：只能执行一次，不能存储在数据库中 过程，函数和包：能够多次执行，存储在数据库中，调用执行 触发器：发生触发事件自动执行 PL/SQL 块结构 定义部分：可选，变量、常量、游标等先定义后使用， DECLARE 可执行部分：必选，主体部分，可以是sql语句和PL/SQL语句, BEGIN … END 异常处理部分：可选, EXCEPTION … END PL/SQL 变量 标识符 至多30个字符 不能是保留字 必须以字母开头 包含字母、$、_、#、数字 不建议与表中字段名相同 惯例 变量：v_name 常量：c_name 异常：e_name 游标：name_cursor 表：name_table Record：name_record sqlplus substitution parameter： p_name sqlplus 全局变量：g_name 变量类型 PL/SQL 变量 标量(不可拆分) CHAR 与Oracle中不同 VARCHAR2 与Oracle中不同 DATE NUMBER：整数使用这个效率低，使用下面两个效率高一些 BINARY_INTEGER PLS_INTEGER BOOLEAN：true, false, null, Oracle中没有BOOLEAN BINARY_FLOAT BINARY_DOUBLE 复合 引用 LOB (大型的对象) 外部变量 SQL*Plus 主机变量 表单应用程序的屏幕域 第二课时 变量声明 identifier [CONSTANT] dataType [Not NULL] [:= | DEFAULT expr] 俗称约定的值用DEFAULT 其他初值 := CONSTANT 常量，常量必须有初值 变量使用 NOT NULL修饰，必须有初值 每条语句后用 ‘;’ 分隔 变量名尽量不和字段名相同 变量赋值 12345-- 只有检索了一行时（多行和0行出错），才成功操作select column into variablefrom tablewhere condition; %Type 属性 和数据库中的字段的数据类型保持一致，并同步 和前面的变量类型保持一致，并同步123v_ename emp.ename%Typev_balance NUMBER(2)v_min_balance v_balance%Type := 10 其他变量 大对象 CLOB 字符类型大对象：食谱 BLOB 二进制类型大对象：照片 BFILE 大对象，数据保存在数据库外：电影 外部变量 :g_salary := :v_value 12345678910111213-- 在sqlplus中定义变量SQL&gt; VARIABLE emp_num NUMBER-- 查询SQL&gt; BEGIN SELECT COUNT(*) INTO :emp_num FROM emp WHERE empno = &amp;emp_no;END;/-- 打印SQL&gt; PRINT emp_num 输出 dbms_output.put_line()1234567891011-- 在sqlplus 中执行需要设置环境变量-- set serveroutput onDECLARE v_ename emp.ename%TYPE;BEGIN select ename into v_ename from emp where empno = 7369; dbms_output.put_line(v_ename);END; 注释 / 多行注释 / – 单行注释 第三课时 PLSQL 中的SQL函数 过程语句有效函数 MOD, ROUND, TRUNC CONCAT, LENGTH, LOWER, SUBSTR to_char, to_date, to_number ADD_MONTHS, SYSDATE, MONTHS_BETWEEN 过程语句无效函数 DECODE 分组函数，只能在sql语句和PL/SQL块中使用 avg, min, max, count, sum PLSQL 中的SQL语句 PLSQL 预编译，只能处理DMl和事务处理，不能处理DDL, DCL SELECT 语句必须使用INTO语句 %TYPE 和 sum() 使用时，要注意结果是否超出范围 PLSQL 中的DML和事务控制语句 DML：和sql中一样 插入数据 更新数据 删除数据 事务控制语句 COMMIT 和 ROLLBACK 结束一个事务 SAVEPOINT 标记中间点12345678910BEGIN insert into temp(x, y) values (1, 'aaa'); savepoint a; insert into temp(x, y) values (2, 'bbb'); savepoint b; rollback to savepoint a; commit;END; PLSQL 中的IF语句 条件分支语句 IF IF - THNE - END IF; IF - THEN - ELSE - END IF; IF - THEN - ELSIF - END IF; case 循环语句 loop 无条件循环 for 有计数循环 while 有条件循环 PLSQL 中的NULL值判断123456789101112131415161718DECLARE v_x pls_integer := NULL; v_y pls_interer := NULL; v_out pls_integer; v_flag BOOLEAN;BEGIN -- v_flag := v_x = v_y; -- 空值不能直接用 '=' 判断 -- 如果判断条件为空，则转到 ELSE v_flag := nvl(v_x, 0) = nvl(v_y, 0); IF v_flag THEN v_out := 100; ELSIF v_flag IS NULL THEN v_out := 150; ELSE v_out := 200; END IF; dbms_output.put_line(v_out);END; 第四课时 逻辑表 123456-- NULL 是一种未知数-- NULL and True --&gt; NULL-- NULL and False --&gt; False-- NULL or True --&gt; True-- NULL or False --&gt; NULL-- NOT NULL --&gt; NULL PLSQL 中的CASE语句 用法一 12345case v_deptno when 10 then '部门一' -- 此时，when后面只能接特定的值，不能是范围 when 20 then '部门二' else '部门三'end; 用法二 12345case when v_sal &lt; 1000 then '薪水太低' when v_sal &gt;= 1000 and v_sal &lt; 2000 then '起步的薪水' else '已经进入软件行业'end; 简单循环 特定：至少执行一次 语法： 1234loop statement; exit [when condition];end loop; for 循环 语法 1234for counter in [REVERSE] -- REVERSE 循环的计数器从大到小 lower_bound..upper_bound loop statement;end loop; 例子 1234for v_count in 1..3 loop insert into test(empno, ename, job) values((v_empno+v_count), v_ename, v_job);end loop; 常见错误 123for v_count in 1..10 loop v_count := v_count + 1; -- 错误，不能更改end loop; WHILE 循环 特点：先检查循环条件 语法： 123while condition loop statement;end loop; 例子 12345while v_count &lt;= 3 loop insert into test(empno, ename, job) values ((v_empno+v_count), v_ename, v_job); v_count := v_count + 1;end loop; 第三单元第一课时 复合数据类型概述 复合变量包含多个内部组件，每个组件单独放值 复合数据类型需要先创建，再声明复合变量 类型 记录：类似C语言中的结构体，可以有多种数据类型 集合：类似C语言中的数组，没有那么多的数据类型 关联数组（index by表) 嵌套表 可变长度数组 记录型 特点 多个字段 无初值的字段为NULL 可以使用NOT NULL限定记录 定义字段时可以使用DEFAULT 可以在任意一个块、子程序或包的声明部分定义RECORD类型并声明用户自定义的记录 一个记录可以是其他记录的组件 定义 12345678-- 创建记录类型TYPE emp_record_type IS RECORD (empno emp.empno%type, -- 域 ename emp.ename%type, job varchar2(9));-- 声明记录类型变量emp_record emp_record_type; 赋值 12345678-- 方式一emp_record.Job := 'CLERK';-- 方式二select empno, ename, jobinto emp_recordfrom empwhere ename = 'SMITH'; %ROWTYPE 属性 table%ROWTYPE emp_record emp%ROWTYPE; 复合变量 例子 123456789101112DECLARE emp_rec emp%rowtype;BEGIN -- 查询 select * into emp_rec from emp where empno = 7788; -- 插入 insert into test values emp_rec; commit;END; 游标概述及隐式游标 游标处理结果集，可以查询多行数据 分类 隐式游标：PL/SQL隐式建立并自动管理，实质上是sql语句 可以使用游标属性从最近执行的sql语句中获取信息 用于处理DML语句以及返回单行查询 显示游标：程序员显示说明并控制，用于从表中取出多行数据，并将数据一行一行单独处理 隐式游标属性 SQL%ROWCOUNT SQL%FOUND，没有执行FETCH语句之前是NULL SQL%NOTFOUND SQL%ISOPEN12345678DECLARE v_deptno number := 20; v_rows_deleted varchar2(30);BEGIN delete from emp where deptno = v_deptno; v_rows_deleted := SQL%ROWCOUNT;END; 显示游标定义 select 查询结果可以单行、多行、0行 游标工作区中，存在指针，初始状态指向查询结果的首记录 通过FETCH语句，进行指针的移动，实现访问查询结果的所有记录 游标操作：定义游标、打开游标、提取游标、关闭游标 游标指针只能前进，不能后退，提取第二行时，第一行数据不可访问，否则需要关闭游标，再重新打开游标才可访问 显示游标的使用 游标声明 12CURSOR cursor_name IS select_statement; -- 查询语句，不能使用into子句 打开游标 12-- 打开游标，实质是执行游标声明时的select语句OPEN cursor_name; 从游标中提取数据 into 子句的变量个数、顺序、数据类型必须与工作区中每行记录的字段数、顺序以及数据类型一一对应 当取数据条数大于结果集条数时，大于的部分结果是最后一条数据(实质没有取出数据，只是结果没有被覆盖)12FETCH cursor_name into [variable1, variable2, ...] | [record_name] 第二课时 显示游标使用的注意事项 关闭游标 12-- 释放内存空间CLOSE cursor_name; 显示游标的属性 %ISOPEN，游标是否打开 12345IF NOT emp_cursor%ISOPEN THEN OPEN emp_cursor;END IF;LOOP FETCH emp_cursor ... %NOTFOUND，如果FETCH没有返回记录，返回True，没有FETCH之前，值为NULL 123456789101112131415161718DECLARE v_empno emp.empno%TYPE; v_ename emp.ename%TYPE; cursor emp_cursor IS select empno, ename from emp;BEGIN -- 打开游标 IF NOT emp_cursor%ISOPEN THEN OPEN emp_cursor; END IF; -- 提取数据 LOOP FETCH emp_cursor INTO v_empno, v_ename; -- 注意EXIT的位置，如果exit在dbms_output之后，则多输出一行 EXIT WHEN emp_cursor%NOTFOUND; dbms_output.put_line(v_empno || ' ' || v_ename); END LOOP; -- while 循环 FETCH emp_cursor INTO v_empno, v_ename; while emp_cursor%FOUND LOOP dbms_output.put_line(v_empno || &apos; &apos; || v_ename); FETCH emp_cursor INTO v_empno, v_ename; END LOOP; -- 关闭游标 CLOSE emp_cursor; END; 12345678910 * %FOUND，如果FETCH返回一条记录，值为True，没有FETCH之前，值为NULL * %ROWCOUNT，当前从游标中取出的记录数目3. 几种简便使用游标的方式 * 游标和记录 ```sql CURSOR emp_cursor IS SELECT empno, ename FROM emp; emp_record emp_cursor%ROWTYPE; -- 复合变量 – 提取数据 FETCH emp_cursor INTO emp_record; dbms_output.put_line(emp_record.empno || ‘, ‘ || emp_record.ename); 1234567* 游标处理中的for循环 - 隐式打开、提取和关闭游标 - 隐式声明记录类型变量 ```sql FOR record_name IN cursor_name LOOP statement; END LOOP; 不需要声明的游标 1234567BEGIN for emp_record in (select empno, ename from emp where ename = 'SCOTT') LOOP dbms_output.put_line(emp_record.empno); END LOOP;END; 带参数的游标 语法 12345cursor cursor_name -- PL/SQL中，这里数据类型不能带长度和精度 (参数1 数据类型, 参数2 数据类型, ...)IS select_statement; 例子 1234567891011121314151617181920212223DECLARE CURSOR cur_emp (p_sal NUMBER) IS select ename, sal from emp where sal &gt; p_sql; rec_emp_test cur_emp%ROWTYPEBEGIN -- for 循环 for rec_emp in cur_emp(2000) LOOP dbms_output.put_line(rec_emp.ename || ' ' || rec_emp.sal); END LOOP; -- 简单循环 OPEN cur_emp(3000); LOOP FETCH cur_emp INTO rec_emp_test; EXIT WHEN cur_emp%notfound; dbms_output.put_line(rec_emp_test.ename || ' ' || rec_emp_test.sal); END LOOP; CLOSE cur_emp;END; 带锁游标及可写游标 默认select不管是否被锁，加上for update便在乎是否被锁并锁定 通过游标更改结果集数据 在更新或删除行时要锁定该行 语法 of column_reference(字段名) 问题：多表查询时加不加会不会有区别？ NOWAIT，被锁后再访问，不等待，返回错误提示123SELECT ...FROM ...FOR UPDATE [OF column_reference] [NOWAIT]; where current of 子句 更新或删除游标中当前行数据 首先要在游标中使用 for update 子句锁定行 语法 1where current of cursor; 例子 12345678910111213declare cursor sal_cursor IS select sal from emp where deptno = 30 for update of sal nowait;begin for emp_record in sal_cursor loop update emp set sal = emp_record.sal * 1.10 where current of sal_cursor; end loop;end; 第三课时 异常的定义 在PL/SQL执行过程中出现的警告或错误 可以使用 RAISE 语句显示触发异常 例子 1234567891011121314-- 输出othersdeclare v_ename emp.ename%type; v_empno number(4) := 736;begin select ename into v_ename from emp where empno = v_empno; dbms_output.put_line(v_ename);exception when others then dbms_output.put_line('others');end; 异常的类型 Oracle服务器异常 预定义异常：有错误名字，不需声明 非预定义异常：没有名字，在声明部分声明 用户定义异常：在声明部分声明 语法 12345678910EXCEPTION when exception1 [or exception2] then statements; when others then -- 必须是异常中的最后一条子句 statements; -- 常见异常类型 /** no_data_found too_many_rows */ 预定义异常 NO_DATA_FOUND TOO_MANY_ROWS 非预定义异常 只有异常代码，没有异常名字，不能直接处理 声明异常 –&gt; 关联 –&gt; 触发 例子 123456789101112declare e_emp_cons exception; pragma exception_init(e_emp_cons, -00001); -- -1是预定义异常，将e_emp_cons与-1关联begin insert into emp select * from emp; -- 重复异常exception when e_emp_cons then dbms_output.put_line('违反唯一性约束'); when DUP_VAL_ON_INDEX then -- error, 与e_emp_cons异常重复，异常冗余 dbms_output.put_line('试图更新或插入重复记录');end; 捕获异常的函数 sqlcode 错误代码 0 没有异常 100 NO_DATA_FOUND 负数 其他异常 sqlerrm 错误信息 12345exception when others then dbms_out.put_line(SQLCODE); dbms_out.put_line(SQLERRM);end; 异常表 sqlcode, sqlerrm 不能直接放到sql语句中12345678910111213141516171819-- 新建异常表create table ERRORS ( objname varchar2(100), -- 对象名一般记录存储过程的名字 edate date, ecode number(6), emsg varchar2(200));-- 异常信息写入异常表declare v_errcode number(6); v_errmsg varchar2(200);beginexception when others then v_errcode := SQLCODE; v_errmsg := SQLERRM; insert into errors(objname, edate, ecode, emsg) values ('', sysdate, v_errcode, v_errmsg); -- sqlcode, sqlerrm 不能直接放到sql语句中end; 用户定义的异常 声明 –&gt; raise手动触发 –&gt; exception中通过名字处理 例子 1234567891011121314declare e_too_many exception;begin update emp set sal = 5000 where deptno = &amp;p_deptno; if SQL%ROWCOUNT &gt; 2 then raise e_too_many; end if;exception when e_too_many then dbms_output.put_line('涨工资人数' || SQL%ROWCOUNT || '太多了'); rollback;end; 异常的传递 一层一层往上传递 Raise_Application_Error过程 Raise_Application_Errors(error_number, message); 错误编号在 -20000 ~ -20999 错误信息长度可达 2048字节 产生错误提醒对话框 既可在可执行部分使用，也可以在异常处理部分使用 例子 12345678910111213declare e_name exception; pragma exception_init(e_name, -20202); -- 非定义异常，没连接不会自动捕获begin delete from emp where deptno = 90; if sql%notfound then Raise_Application_Errors(-20202, '部门号不存在'); -- 不会执行，有异常处理 end if;exception when e_name then dbms_output.put_line(sqlcode); dbms_output.put_line(sqlerrm);end; 第四课时 存储过程概述 子程序是命名的PL/SQL 块，能够接收传递的参数，能够被调用 子程序的类型 过程: 用于执行某项操作 函数: 用于执行某项操作并返回值 存储过程 存储在数据库中 存储过程的创建 创建语法 replace表示如果过程存在，则删除重建 PL/SQL 块，既可以用begin开始也可以用局部变量的声明开始，既可以用end结束也可以用 end procedure_name结束 模式 输入的，默认模式 输出的 既能输入又能输出的1234create [or replace] procedure procedure_name[(参数1 [模式1] 数据类型， 参数2 [模式2] 数据类型, ...)]IS | AS -- 变量或常量的声明，代替declarePL/SQL 块 存储过程的参数 模式 in，进入过程 out in out 实例 过程 1234567891011121314create or replace procedure raise_sal(p_id in emp.empno%type, p_name out varchar2, p_sal in out number)ISBEGIN update emp set sal = sal + p_sal -- 输入 where empno = p_id; select sal, ename into p_sal, p_name -- 输出 from emp where empno = p_id;END raise_sal; 调用 1234567declare v_sal emp.sal%type := 500; v_name emp.ename%type;begin raise_sal(7369, v_name, v_sal); dbms_output.put_line('雇员：' || v_name || '的薪水是：' || v_sal);end; 使用工具创建存储过程 创建过程后先编译，然后在sql窗口中使用 过程中可以加上异常处理 存储过程传递参数的方法 位置 实际参数与形式参数排列的顺序相同1get_annual_income(7369, v_ann_sal); 指定 实际参数联合其相应的形式参数以任意顺序排列1get_annual_income(p_ann_sal =&gt; v_ann_sal, p_empno =&gt; 7369); 组合 实际参数的排列一些用位置，一些用指定 组合法先按照位置，再按照指定1234get_annual_income(7369, p_ann_sal =&gt; v_ann_sal);-- error，位置法传参数不能在指定法后面get_annual_income(p_empno =&gt; 7369, v_ann_sal); 第四单元第一课时 过程参数详解 in模式参数在 pl/sql中是只读的，不可以更改 out或in out模式参数不能有默认值 参数有默认值 p_empno in emp.empno%TYPE default 7749; 如果默认参数在参数列表的前面，调用过程时，使用位置法，不能省略有默认值的参数；使用指定法，则可以省略； 如果默认参数在参数列表的后面，调用过程时，使用位置法或指定法，都可以省略有默认值的参数； 过程中处理异常 过程1调用过程2，如果过程2发生异常，并且异常得到处理，那么在过程1中就不再处理； 然而，如果过程2中发生的异常，没有得到处理，那么在过程1中就要处理这个异常； 删除过程 删除存储在数据库中的过程1drop procedure procedure_name; 权限 系统权限 create (any) proceduere alter any procedure drop any procedure execute any procedure 对象权限 execute 授权访问数据 直接访问 1234grant select on emp to LjsGrant Successed. 间接访问 1234grant execute on query_emp -- 过程 to GreenGrant Successed. 所有者权限 vs 调用者权限 所有者权限 创建用户 1234-- 授权需要在 sysdba 下create user test identified by test;grant connect, resource to test;grant execute on get_annual_income to test; -- 过程权限，间接访问 emp test用户直接访问 scott.emp 1select * from scott.emp; -- 表和视图不存在 test用户间接访问 scott.emp; 123456declare v_ann_sal number(9, 2);begin scott.get_annual_income(v_ann_sal, 7788); dbms_output.put_line(v_ann_sal); -- 56000end; 调用者权限 创建用户 1234create user test identified by test;grant connect, resource to test;-- grant execute on scott.get_annual_income_authid to test; -- 调用者权限，直接或间接访问都访问不到grant select on scott.emp on test; -- 调用者权限，可以间接访问 test用户直接访问 scott.emp 1select * from scott.emp; -- 表和视图不存在 test用户间接访问 scott.emp; 1234567891011121314-- 给过程添加调用者权限create or replace procedure scott.get_annual_income_authid (p_ann_sal out number, p_empno in emp.empno%TYPE)authid current_user -- 标志IS v_sal emp.sal%type v_comm emp.comm%typebegin select sal, nvl(comm, 0) into v_sal, v_comm from scott.emp -- 需要添加scott where empno = p_empno;end; 12345678 ```sqldeclare v_ann_sal number(9, 2);begin scott.get_annual_income_authid(v_ann_sal, 7788); -- 56000 dbms_output.put_line(v_ann_sal);end; 第二课时 包的概览 组成： 声明（包头） 体（包体） 包本身不能被调用、被参数化或被嵌套 用户只能访问到包头，包体隐藏 保存包声明和包体到两个不能的sql文件，便于修改 包声明可以独立存在，但包体不可以 创建包 创建包声明语法 1234567-- replace 删除并重建-- 包声明的变量默认初始化为 nullcreate [or replace] packagepackage_nameIS | AS 公共变量、异常、游标、子程序等声明END package_name; 创建包体语法 1234567-- 包体中定义的标识符是私有结构，在包的外部不可见-- 在包体中先定义私有变量和子程序，后定义公共子程序create [or replace] package body package_nameIS 私有的变量、静态变量、游标、异常、类型、子程序end package_name; 声明无体包 例子 123456789create or replace package global_constsIS mile_2_kilo constant number := 1.6093; kilo_2_mile constant number:= 0.6214;end global_consts;-- 使用execute dbms_output.put_line('20 miles = ' || 20 * global_consts.mile_2_kilo || 'km');-- 也可以在过程中使用 删除包 删除包声明和包体 1drop package package_name; 只删除包体 1drop package body package_name; 开发包的原则 先定义包声明，再定义包体 包声明应该只包含公共结构 改变包的声明需要重新编译每个涉及到的子程序 包体的变化不要求重新编译包的声明 包声明应该尽可能包含少的内容 包体的隐藏性 在包体中的私有结构是隐藏和不可访问的 在包体中所有的代码都是隐藏的 使用oracle提供的包 函数的介绍 能够返回值 能够作为表达式的一部分被调用 命名 过程 get_annual_income 函数 annual_income sql语句中允许表达式的地方都可以使用函数，比如select、where，但不能使用过程 语法 12345create [or replace] function function_name [(parameter1 [mode1] datatype1, ...)] -- 建议函数都取 in 模式，sql语句调用带out模式参数，没法调用return datatypeIS | ASPL/SQL block -- *PL/SqL 块至少又一个 return 语句* 函数创建 新建 Function 1234567891011121314151617create or replace function annual_income (p_empno emp.empno%type)return numberIS v_ann_sal NUMBER(9, 2);begin select sal*12 + nvl(comm, 0) * 10 + 20000 into v_ann_sal from emp where empno = p_empno; return (v_ann_sal);exception when no_data_found then return(0); when others THEN return(0);end annual_income; 调用 123456declare v_ann_sal number(9, 2);begin v_ann_sal := annual_income(7369); dbms_output.put_line(v_ann_sal);end; select 语句 12345select annual_income(7369) -- 29600from dual;select annual_income(empno) -- 可以是字段名，奇怪，显示全部结果from dual; sql调用函数的限制 函数 123456789create or replace function dml_call_sql (p_sal number)return numberisbegin insert into emp(empno, ename, hiredate, job, sal) vaules(1, 'qixqi', sysdate, 'manager', 1000); return (p_sal + 100);end; 调用 PL/SQL 块，可以插入语句 select 语句，报错，查询语句不能处理 dml 操作 update 语句，报错，表scott.emp发生了变化，函数不能读它 12update emp set sal = dml_call_sql(3000);where empno = 7369; delete 语句，报错，表scott.emp发生了变化，函数不能读它 12delete from empwhere sal = dml_call_sql(700); 为了sql调用函数，有以下限制 直接收 in 参数 直接收有效的sql数据类型，不接受pl/sql特殊类型，比如不能是布尔值 返回数据类型为有效的sql数据类型，而非pl/sql特殊类型 在一个表的update 或 delete语句中调用的函数不能查询及更新同一个表 (疑问：insert、select可以吗) 从sql中调用的函数不能包含结束事务的语句，比如提交、回滚sql最好处理逻辑，尽量不包含sql语句&lt;插入、修改、删除&gt; 过程 vs 函数 过程可以返回多个值，函数必须返回单个值 用户计算的、返回单个值的一般用函数 删除函数 1drop function function_name; 第三课时 动态sql PL/SQL 是预编译的，所以ddl、dcl语句不能直接用到pl/sql中 ddl 和 dcl语句需要使用动态sql来实现 动态sql实现 调用 DBMS_SQL包 本地动态sql sql 语句执行顺序 解析 绑定 执行 取回 动态语句效率低，尽量使用静态的 例子 1234567create or replace procedure delete_all_rows (p_tab_name in varchar2, p_rows_del out number)is begin delete from p_tab_name; -- 执行才传入参数，编译是错误 p_rows_del := sql%rowcount;end delete_all_rows; DBMS_SQL包 常用过程函数：OPEN_CURSOR、PARSE、BIND_VARIABLE、EXECUTE、FETCH_ROWS、CLOSE_CURSOR 例子 123456789101112131415create or replace procedure delete_all_rows (p_tab_name in varchar2, p_rows_del out number)is cursor_name integer;begin cursor_name := DBMS_SQL.OPEN_CURSOR; DBMS_SQL.PARSE(cursor_name, 'DELETE FROM ' || p_tab_name || ' where sal &gt; :x', DBMS_SQL.NATIVE); -- :x 变量 DBMS_SQL.bind_variable(cursor_name, 'x', 3000); p_rows_del := DBMS_SQL.EXECUTE(cursor_name); DBMS_SQL.CLOSE_CURSOR(cursor_name);end delete_all_rows;-- 执行动态sql删除行variable deleted numberexecute delete_all_rows('emp', :deleted); 本地动态sql 推荐使用 语法 动态sql: 动态sql语句（不带结束符），PL/SQL块(带结束符) 单行查询 多行查询使用 open, fetch, close123execute immediate '动态sql'[into 变量列表] -- 只能返回一行结果[using 绑定参数列表] 例子 1234567891011121314create or replace procedure test_sql (p_no number)is v_name varchar2(10); v_loc varchar2(10);begin execute immediate 'select dname, loc from dept where deptno = :1' into v_name, v_loc using p_no; dbms_output.put_line(v_name || ' ' || v_loc);exception when others then dbms_output.put_line('others');end test_sql; 数据库触发器 隐式执行，针对特定事件触发 大的应用程序，触发器使用维护困难 能够使用 check约束，就不用触发器 触发器很长，将算法写到过程中，然后触发器调用过程 类型 应用程序触发器 数据库触发器 dml 触发器 触发时间 表: before, after 视图: instead of 触发事件: insert, update, delete 表名: on table, view 触发器类型 row，一条语句影响多少行触发多少次，如果没有行被影响则不触发 statement，一条语句触发一次，即使没有行受到影响 WHEN子句，限制条件 触发器体 创建DML语句触发器语法 123456create [or replace] trigger tirgger_name[before | after] -- before: 验证, after: 同步[insert | update [of column] | delete] -- update of column 只有这个字段修改才会触发on table_nameTrigger_body 创建DML行触发器语法 12345678create [or replace] trigger trigger_name[before | after][insert | update [of column] | delete]on table_name[referencing OLD as old | NEW as new]for each row[when (condition)]Trigger_body 只有行触发器可以使用 OLD 和 NEW 触发器中不能加入事务处理，比如commit，应该两个表能够同时回滚 行触发器中，在数据改变前后，可以使用 OLD 和 NEW 限定词作为前缀引用一个列的值 | 数据操作 | OLD值 | NEW值 | | :-: | :-: | :-: | | insert | null | 插入的值 | | update | 更新以前记录的值 | 触发器完成后，更新的值 | | delete | 删除以前记录的值 | null | 例子 123456789-- 审计表create or replace trigger audit_emp_valuesafter delete or insert or update on empfor each rowbegin insert into audit_emp_table(user_name, timestamp, old_empno, new_empno, old_ename, new_ename, old_job, new_job, old_sal, new_sal) values (USER, sysdate, :OLD.empno, :NEW.empno, :OLD.ename, :NEW.ename, :OLD.job, :NEW.job, :OLD.sal, :NEW.sal);end; 12345678-- 带有限制的行触发器create oro replace trigger sal_empbefore insert or update of sal on empfor each rowwhen (new.job = 'MANAGER') -- 只有新工作是manager是触发begin raise_application_error(-20001, '需要关注');end; DML 触发器的触发事件 触发顺序 before 语句触发器 before 行触发器 after 行触发器 before 行触发器 after 行触发器 … after 语句触发器 合并多个事件的触发器 123456789101112131415create or replace trigger sal_empbefore insert or update or delete on empbegin if (to_char(sysdate, 'HH24:MI') not between '08:00' and '17:00') then if deleting then raise_application_error(-20001, '非工作期间不允许删除数据'); elsif inserting then raise_application_error(-20002, '非工作期间不允许插入数据'); elsif updating('sal') then raise_application_error(-20003, '非工作期间不允许修改数据'); else raise_application_error(-20004, '非工作期间不允许修改数据'); end if; end if; end; 数据库触发器与存储过程的区别 触发器不允许 commit,savepoint,rollback，过程允许 如果一个触发器编译期间错误，该触发器仍会创建 维护触发器 123456789101112-- 禁用或重用触发器alter trigger trigger_name disable | enable-- 禁用或重用一个表所有的触发器alter table table_name disable | enable all triggers-- 重新编译触发器alter trigger trigger_name compile-- 删除触发器drop trigger trigger_name;-- 当表删除时，表上的触发器都被删除 视图触发器 使用视图触发器可以实现对视图 insert、update、delete 语法 1234567create or replace trigger tirgger_nameinstead of[insert | update [of column] | delete]on view_name[referencing OLD as old | NEW as new]for each rowTrigger_body 例子 123456789create or replace trigger sal_empinstead of insert on my_viewfor each rowbegin insert into dept(deptno, dname) values (90, 'neu'); insert into emp (empno, ename, job, sal, deptno) values(1005, 'ljs', 'clerk', 2000, 90);end; 第五单元第一课时 Oracle 数据类型概述 char varchar2 number date blob bfile clob rowid 数值类型 number(precision, scale) 精度高 precision 总位数，默认38 scale 小数位数 precision &lt; scale 没有整数的小数 1number(2, 3) 0.012对， 0.12错 binary_float、binary_double 精度低，计算快 simple_integer, 效率非常高，不为空，也不溢出时使用 字符类型 char 定长，效率高 varchar2 可变长度, varchar是sql标准，但建议使用 varchar2 nchar, nvarchar2，处理多字节，如中文，处理unicode字符集 oracle 与 pl/sql 数据类型的不同 varchar2: oracle 4000字节, pl/sql 32767 char: oracle 2000, pl/sql 32767 oracle 不支持布尔，pl/sql可以布尔 oracle12c 后，varchar2最大长度可以修改成32767 max_string_size standard 4000 max_string_size extended 32767 查看当前数据库的字符集 123select * from nls_database_parameterswhere parameter = 'NLS_CHARACTERSET'; char vs nchar char(6) 充满：’一二三’ ‘abcdef’ nchar(6) 充满：’一二三四五六’ ‘abcdef’ 日期类型 date：世纪、年、月、日、小时、分钟、秒 timestamp 时间戳，精确到毫秒，支持时区 interval 两个时间戳之间的间隔 第二课时 大对象 常见类型 BLOB：二进制，保存在数据库内 BFILE：二进制，保存在数据库外 CLOB：处理字符，能用字符类型处理就尽量用字符类型 NCLOB：处理字符 lob 对象组成 指针，查询lob对象返回指针 数据内容 普通类型与大对象可以分开存储 12345678910111213create table proposal( proposalId number(10), propsalName varchar2(20), propsalText clob, budget blob, cover bfile, constraint proposal_pk primary key(proposalId))tablespace proposalslob(proposalText, budget) store as (tablespace proposals_lobs storage (initial 100K next 100K pctincrease 0) chunk 16k pctversion 10 nocache nologging); lob数据的处理 较小的使用 varchar2数据的字符串函数处理 较大的使用 dbms_lob 包或 oci程序处理 空定位器与null值 如果lob列值为null,则首先设置为空定位器（初始化lob），然后才能更新为非null blob: empty_blob() clob: empty_clob() bfile: bfilename() 使用bfilename函数指向一个目录和文件名的组合值，但必须先创建目录对象 插入数据时，bfile数据指向的文件不一定必须存在 lob 续 实例 123456789101112131415161718192021222324252627282930313233-- 服务器端存在文件 C:\img\1.jpg, 当且用户对目录有读权限create directory img as 'c:\img';grant read on directory img to xxx;-- 创建过程create or replace procedure insert_image(img_dir varchar2, img_name varchar2)is img_blob blob; img_bfile bfile;begin -- blob数据初始化为空定位器 insert into fw.my_image values(empty_blob()) return fw.my_image.img into img_blob; -- 获得定位器指向的目录和文件 img_bfile := bfilename(img_dir, img_name); -- 判断文件是否存在 if (dbms_lob.fileexists(img_bfile) != 0) then -- 打开文件 dbms_lob.fileopen(img_bfile, dbms_lob.file_readonly); -- 将文件字节流加载到指定的lob数据变量中 dbms_lob.loadfromfile(img_blob, img_bfile, dbms_lob.getlength(img_bfile)); -- 关闭文件 dbms_lob.fileclose(img_bfile); commit; dbms_output.put_line('已经从' || img_dir || '目录获取了图片' || img_name || '向表中插入'); else dbms_output.put_line('文件未找到'); end if;exception when others then dbms_output.put_line(sqlerrm);end; 更新lob数据 1img_bfile := bfilename(img_dir, img_name); 使用字符串处理lob数据 clob substr, instr, ltrim 提高大对象使用效率 数据分区技术 压缩数据技术 针对列数据库效果较好 并行处理技术 物化视图技术 保存结果中的数据 应用：数据仓库 RAC技术 高可用，坏了可以切换 rowid/urowid 类型 即使没有主键，相同的两行凭借 rowid 也是可以区分的 rowid组成 数据库对象编号 对应文件编号 块编号 行编号 urowid 用于没有rowid或没有固定rowid的表，比如索引组织表(IOT) 第三课时 序列 主键自动增加 12345678-- sql serverint identity(1,1) -- 从1开始，每次增加1-- mysqlauto_increment-- oracle12c之后number(9) generated as identity(start with 100 increment by 10) -- 从100开始，每次增加10 oracle12c之前使用序列，保证主键不重复 序列：计数器，每使用一次，增加1 创建序列 1234567create sequence sequence_name [increment by n] -- 每次增加n，默认1 [start with n] -- 从n开始，默认1 [maxvalue n | nomaxvalue] -- 最大值，默认没有最值 [minvalue n | nominvalue] -- 最小值 [cycle] -- 在最小值与最大值之间循环，默认不循环 [cache] -- 放20个数值到缓存里，快 使用序列 NEXTVAL：序列自动增加到下一个序号 1select sequence_name.NEXTVAL from dual; 一般在插入语句中使用 操作失败、rollback，序列仍然会自动增加，序列不保证连续 1insert into emp(empno) values (sequence_name.nextval) CURRVAL：当前值 1select sequence_name.CURRVAL from dual; 修改序列 12345alter sequence sequence_name [increment by n] [maxvalue n | nomaxvalue] [minvalue n | nominvalue] [cycle | nocycle] oracle11g前后序列赋值给变量用法 123456-- oracle11g 之前select sequence_name.nextval into v_xfrom dual;-- oracle11g 之后v_x := sequence_name.nextval; 视图 种类 关系视图：虚表，没有数据 内嵌视图 对象视图 物化视图 创建视图 创建视图之前获取权限：sys: grant create view to scott tab 表集合 user_views 视图字典集合 update、delete、insert视图，对应的表也会改变123456create [or replace] [force | noforce] view -- 默认noforce，force表示表不存在时也创建视图 [user] view_name [column1[, column2]...] -- 重新命名字段 as query [with check option [constraint constraint_name]] -- 约束 [with read only] -- 只读 删除视图 12-- 表中数据不变drop view view_name; 检索视图定义 1select * from user_views where view_name = 'MY_VIEW'; -- 视图名必须大写 视图不能删除和插入的情况 分组函数 group by distinct 表达式 rownum伪列 此外，insert还要注意没有包含在视图中的字段是否允许null 此外，两者还要注意 with check option约束 表改变后，重新编译视图 12345-- 重新编译alter view view_name compile-- 重新创建create or replace view 内嵌视图 更虚的虚表，就是一个子查询 12345select ename, sal, r1, ROWNUM r2from (select ename, sal, ROWNUM r1 from emp order by sal DESC)where rownum &lt;= 5; -- rownum 只能&lt;=，不能&gt;=，比如 rownum &lt;= 10 and rownum &gt;=6 是有问题的 对象视图 不需要重新修改表结构 123456789101112131415-- 创建对象create type emp_obj is object( id number(38), ename varchar2(30), email varchar2(30));-- 创建基于对象的表create table emp of emp_obj;-- 创建视图create view emp_email of emp_objwith OBJECT OID(id)asselect emp.id, emp.email from emp; 物化视图 保存(计算)结果 适合表变化比较小，数据量大 语法 12345create materialized view vw_materialasselect empno, count(*) total_empfrom empgroup by empno; 同义词 表、视图、序列、过程或其他对象的别名（不包括包名）、 tab 就是同义词，没有带方案名scott(比如scott.emp) 语法 12345-- 创建同义词create [public] synonym synonym_name for object_name; -- 默认私有-- 修改同义词drop [public] synonym synonym_name; -- public 表明当前修改的同义词是否是公有的，否则出错 第四课时 索引 复合索引 多个字段 字段顺序：第一个字段索引效率最高 12create index idx_ename_empnoon emp(ename, empno); 反转键索引 处理数据前面多位一样，后面不一样，反转后，使数据分散开 反转键索引更大、更空，消耗更多I/O 用法：创建索引时末尾添加关键字 reverse 位图索引 适合数据仓库，数据变化不频繁 适合相异基数低，即值种类少，比如性别 适合有大量即席查询，即查询条件新定义，事先不知道1create bitmap index job_idx on Emp(job); 基于函数的索引 12create index video_engname_upper_idxon Video(upper(VEngName)) -- 字段作为函数参数 索引优缺点 优点：提高数据检索的效率 缺点：过多的索引影响DML操作性能 获取索引信息 1234567891011-- 查看用户建立的索引select * from user_indexs where table_name = 'VIDEO';-- 查看索引的细节select * from user_ind_columns where table_name = 'VIDEO';-- 修改索引alter index video_name_upper_idx RENAME TO vupper_idx;-- 删除索引drop index insert_name; 表类型 堆表 最基本的表类型 数据无序 外部表 数据库外 123456789101112131415161718-- 创建目录对象create directory ext_data_diras 'D:\'; -- windows目录大小写无关，Linux有关-- 创建外部表create table table_ext( column1 &lt;data_type&gt;, column2 &lt;data_type&gt;, ...)organization external( type oracle_laoder default directory directory_name access parameters (fields terminated by ',') location('example.csv'))reject limit unlimited; 索引组织表 存储索引，提高查询效率 牺牲插入与更新性能 不经常变化，因为对DML语句产生负面影响 创建索引组织表 12345678910create table table_iot( first varchar2(15), second varchar2(15), last varchar2(2000), constraint pk_first primary key (first) -- pk_first约束名，与constraint成对出现，没有则系统命名)organization index -- 索引组织表tablespace users pctthreshold 20 -- 溢出比例，溢出后放到溢出区including second -- 从second列之后，所有的列存到溢出区overflow tablespace others; -- 溢出表空间 分区表 表划分为多个分区 簇表 经常一起使用的表存储在一起 散列簇表 临时表 事务处理和会话期间存在数据的表 1234create global temporary table temp( first varchar2(15), second varchar2(15), last varchar2(2000) on commit preserve rows; – 会话临时表 / on commit delete rows; – 事务临时表 索引基本概念 一种数据结构，可以迅速的访问表中的数据 最常用的是B+树索引结构 表 代表实体 创建 schema_name 方案名，一个用户所有的数据库集合，一般与表名一样，但是新建用户后，该用户没有任何数据库，此时没有方案名12345678create table [schema_name.]&lt;table_name&gt;( &lt;column_name&gt; &lt;data type&gt; [default &lt;expression&gt;] [&lt;constraint&gt;], ...)organization index -- 建立索引组织表[including column_name][compress n]-- 省去表空间可选内容 约束 列级约束 not null 不能是表级约束 表级约束 复合主键只能作为表级约束，不能在每个字段后添加 primary key 约束修改 12345678-- null / not nullalter table Departmentmodify (DAddr not null);-- 其他约束，这些约束只能删除重建alter table Dept_Videoadd constraint chk_DVTypecheck (DVType in (1,0)); 唯一约束与null的碰撞 oracle 唯一约束允许有两个null sql server 唯一约束不允许有两个null 启动与禁止现有约束 12345alter table Dept_Videoenable constraint chk_DVType;alter table Dept_Videodisable constraint chk_DVType; 删除约束 12 alter table Dept_Videodrop constraint chk_DVType; -- 约束名&lt;自定义或系统创建&gt; / primary key / unique(字段) 修改表 alter table 添加列，添加到最后 12alter table table_nameadd new_column_name datatype [not null]; 改变列名 12alter table table_namerename column old_column_name to new_column_name; 修改数据类型，大类修改（比如数值到字符串）必须 12alter table table_namemodify column_name new_datatype; 删除列 12345678alter table table_namedrop column column_name; -- 只能删除一个字段alter table table_namedrop column_name1, column_name2, ...; -- 删除多个字段alter table table_nameset unused column column_name; -- 避免数据量较大的表整体重写 更改表名 1rename old_table_name to new_table_name; -- ddl，不可以rollback 删除表 12-- cascade constraints, 删除表时，删除所有子表的外键约束drop table table_name [cascade constraints]; truncate table DDL, 不可rollback, 比delete高效 truncate 把表的存储空间释放掉，与delete不同，所以truncate不可rollback 删除表中数据，删除表的索引，不删除表结构12truncate table [schema.]table_name[drop storage | reuse storage] -- 是否重新利用为表分配的全部空间 oracle数据字典视图 dba_xxx &gt; all_xxx &gt; user_xxx user_xxx 拥有的，比如user_tables, user_views; all_xxx 访问到的，比如all_tables, all_views; dba_xxx 所有的，比如dba_tables, dba_views; 删除表 1drop table test purge; -- 不放回到回收站 创建表 建普通空表 子查询建表 不继承约束123create table table_name as ( select statement); 第六单元第一课时 管理安全性 oracle 三种用户认证 口令认证 操作系统认证：sqlplus / as sysdba 全局认证 创建用户 1234567891011create user username identified by password;-- 修改账号口令alter user username identified by password;-- 删除用户drop user username [cascade]; -- cascade：删除用户之前，删除所有表、视图-- 锁定和解锁用户alter user username account [lock | unlock]; 默认的数据库用户 sys 老大 除非需要安装属于sys的额外的数据字典对象，否则不应使用sys进行数据库操作 system 比sys权限小 默认的数据库管理员账号，可以使用system 启动一个新的数据库 权限管理 123456789-- 新建用户create user test1 identified by test1;-- create session 权限grant create session to test1; -- 可以连接数据库系统-- create table 权限grant create table to test1; -- 可以创建表-- 现在仍然创建不了表，没有分配表空间 权限分类 对象权限 对于数据库对象 系统权限 其他 系统权限授权与撤销 12345678-- 授权grant &#123;权限1 [, 权限2, ...] | all [privileges]&#125; to &#123;用户1 [, 用户2, ...] | public&#125; -- public 对于所有用户 [with admin option] -- 权限是否可以传递-- 撤销revoke &#123;权限1 [, 权限2, ...] | all [privileges]&#125; from &#123;用户1 [, 用户2, ...] | public&#125; 系统权限 create table vs create any table create table 只有自己的模式（某个用户的数据库对象） create any table 其他模式也可以 drop any table 可以删除其他模式中的表 create any procedure 允许用户创建、修改、删除或执行任何存储过程、包、函数 开发人员权限：creat table, create view, create type 对象权限 了解 select 权限针对表，不能针对字段 角色与权限管理 角色是一组权限的集合 1234567891011121314151617181920212223-- 创建角色create role role_name;-- 删除角色drop role role_name;-- 系统权限-- 授权角色权限grant &#123;权限1 [, 权限2, ...] | all [privileges]&#125; to &#123;角色1 [, 角色2, ...] | public&#125; -- public 对于所有用户 [with admin option] -- 权限是否可以传递-- 撤销角色权限revoke &#123;权限1 [, 权限2, ...] | all [privileges]&#125; from &#123;角色1 [, 角色2, ...] | public&#125;-- 将角色授予其他用户或角色grant role_1 [, role_2] ... to &#123;user_1 [, user_2, ...] | public | role_1 [, role_2, ...]&#125; [with admin option]-- 撤销授予用户或其他角色的角色revoke role_1 [, role_2] from &#123;user_1 [, user_2, ...] | public | role_1 [, role_2, ...]&#125; 第二课时 并发性 关系型数据库事务特征 原子性 一致性 隔离性 持久性 oracle事务组成 一组DML语句 一条DDL语句 一条DCL语句 oracle事务结束语句 commit rollback 隐式结束语句 一条DDL或DCL语句 用户正常退出 sqlplus 系统崩溃: callback oracle事务开始语句 第一条DML语句 oracle 默认是行级锁 两个登陆同时修改同一个表中的同一条记录，等待事务提交 两个登陆同时修改同一个表中的不同记录，不等待 oracle 检测到死锁时，牺牲一边，释放锁 事务的隔离级别 多个并发事务之间的隔离程度 脏读 读取到另一个事务没有提交的更改信息 oracle不允许 不可重复读取 另一个事务更改信息并提交，造成本事务前后查询结果不一致 问题不大 幻像读取（虚读） 事务1将工资翻倍，事务2插入一个用户，事务1查询到有员工工资未翻倍 事务隔离级别 | 隔离级别 | 脏读 | 不可重复读取 | 幻像读取 | | :-: | :-: | :-: | :-: | |READ UNCOMMITED | 允许 | 允许 | 允许 | |READ COMMITED | | 允许 | 允许 | |REPEATABLE READ | | | 允许 | |SERIALIZABLE | | | | oracle支持READ COMMITED和SERIALIZABLE 隔离级别越高，并行程度越低，效率越低，所以oracle默认READ COMMITED 完整性约束与事务 oracle默认每条SQL语句立即检查是否满足约束 immediate oracle也可以提供延迟检查 deferrable 第三课时 层次查询 语法 12345select [level], column, expr ... -- level 层from table[where condition(s)][start with condition(s)] -- 查找开始点[connect by prior condition(s)]; -- 控制从上往下、从下往上 查找方向 从上往下：使用employees表，connect by prior employee_id = manager_id 从下往上：使用employees表，connect by prior manager_id = employee_id 从上往下：column1 = parent, column2 = child 从下往上：column1 = child, column2 = parent*层123456column org_chart format A12select lpad(last_name, length(last_name)+(level*2)-2, '_') as org_chartfrom employeesstart with last_name = 'King'connect by prior employee_id = manager_id; 修建分支 删除节点 1where last_name != 'Higgins' 删除分支 1connect by prior employee_id = manager_id and last_name != 'Higgins'; oracle体系结构 dba oracle内存结构 SGA：系统全局区 共享 结构 共享池 LRU 库缓存：最近使用的sql语句 数据字典缓存：最近定义的数据 数据缓冲区 LUR 查询返回的数据 日志缓冲区 表记录改变的日志 large pool(可选) 不是LRU java pool(可选) PGA：程序全局区 独占 第四课时 oracle物理结构 oracle database(必须) 数据文件 控制文件 重做日志文件 参数文件 1234567891011-- 参数文件show parameter spfile-- 控制文件select * from v$controlfile-- 数据文件select file_name from dba_data_files-- 日志文件select * from v$logfile 口令文件 归档日志文件 重做日志文件写满放到归档日志文件 服务器进程 服务器进程就是代表客户会话完成工作的原理 模式 专用服务器模式 共享服务器模式 数据写进程 日志写进程 日志写进程优先于数据写进程 总览 oracle逻辑 数据库 &gt; 表空间 &gt; 段 &gt; 区 &gt; oracle块 扩展表复制结构与数据 123create table emp_newas select * from empwhere empno is null; 在一个表的update 或 delete语句中调用的函数不能查询及更新同一个表 (疑问：insert、select可以吗) number(2, 6) 0.0000123 对吗 问题 sql实现分页(rownum) drop table test, 不是DDL吗，怎么还能找回]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>oracle</tag>
        <tag>PL/SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[J2EE 学习]]></title>
    <url>%2F2020%2F03%2F27%2Fj2ee-learn%2F</url>
    <content type="text"><![CDATA[第二讲 url: 协议 域名 端口 url 包含: 协议 + 主机 + 文件路径 文件路径 = web应用的上下文路径 + 文件在当前web应用中路径 url 中❓ 后是查询字符串，名值对区分大小写 比如 http://www.baidu.com/s?wd=hello&amp;encoding=utf-8&amp;page=15 后台语言: JAVA C# PHP Node.js Servlet 中的函数必须会 1234567891011121314151617181920212223242526javax.servlet.Servlet javax.servlet.ServletRequestjavax.servlet.ServletResponsejavax.servlet.http.HttpServletjavax.servlet.ServletConfigjavax.servlet.ServletContextjavax.servlet.http.HttpServletRequestjavax.servlet.http.HttpServletResponsejavax.servlet.http.Cookiejavax.servlet.http.HttpSessionjavax.servlet.Filter 编码 国标： GB2312 GBK GB18030 UTF –&gt; UCF（四个字节 2^31） 编码推荐使用 utf-8 getParameter() 函数必考 Web 传文档之前： 123// Content-Type: text/html// Content-Length: 13708 文档长度，显示下载速度 smtp 1// 简单邮件传输协议，起初只支持7位 ascii码，现在支持8位数据传输 base64 编码 1// 在24位缓冲区中，每6比特转换位一个 ascii 字符，空间大致变为原来的 4/3 swift 语言 1// 有空学学 http 缓存原理（浏览器缓存） 原理 http 响应代码 123456// https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status// 1** 信息响应// 2** 成功响应// 3** 重定向// 4** 客户端响应// 5** 服务端响应 Calendar (MIME) 123456789// text/plain 纯文本// text/html// text/xml 可扩展自标语言// text/json 传输数据// application/pdf// application/octet-stream 下载文件包// application/x-download 同上// Content-Disposition: filename=a.zip 自动保存文件名 第四讲 web.xml 中的session配置时间是分钟 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeoiut&gt;&lt;/session-config&gt; javax.servlet.http.Session 中的设置时间是秒 1getMaxInactiveInterval(); javax.servlet.http.Session 中的函数 12345678// getAttribute(String name)// getAttributeNames()// getLastAccessedTime() --&gt; long// getMaxInactiveInterval()// invalidate()// removeAttribute(String name)// setAttribute(String name, Object value)// setMaxInactiveInterval(int interval) Web 应用中自定义的类最后支持序列化 123pubilc class Cart implements java.io.Serializable&#123; // 没有方法，仅用于 标示&#125; 可序列化类的所有子类型都是可序列化的 使用 session 的三种手段 123// Cookie(客户端)// url 重写// 隐藏域 没有Cookie，就没有Session 提交参数空串与null123456789101112String pageSize = request.getParameter("pageSize");// http://localhost:8080/a/abc.jsp?pageSize=&amp;page=1// 结果是空串// http://localhost:8080/a/abc.jsp?pagesize=123// 返回null// 解决if(pageSize == null)&#123; pageSize = "";&#125; RequestDispatcher forward 在 response uncommited 前使用，只处理头信息，不能包含响应信息 forward 前后都不能处理 response，转发给新页面处理 include 中的编码可以被 /servlet/b 中的编码覆盖 123456789RequestDispatcher rd = request.getRequestDispatcher("/servlet/b");// /servlet 前的/ 是当前web应用中的根，不一定是服务器的根request.setAttribute("data", ...);rd.forward(request, reponse); // 在新页面获取rquest 中的信息response.rd.include(request, response) // 后续代码继续处理 课后扩展 List, Set, Map ServletConfig ServletContext Cookie 分布式内存 Maven 安装 jar包 第五讲 String contextPath = request.getContextPath(); 上下文地址 12345// url = http://localhost:8080/j2ee1/servlet/a?abc=123&amp;a=456// 结果不唯一// servlet url为/servlet/a, 则返回 "/j2ee1"// 部署在根下，返回 "" get 方式提交数据通常是检索，改变数据可以用post get 方式处理 和 post 方式处理(编码问题) 12345&lt;!-- 表单action的地址服务器解析，所以要相对服务器的根 --&gt;&lt;form action="/j2ee1/servlet/a" method="post"&gt; &lt;input type="text" name="wd" /&gt; &lt;input type="submit" value="search" /&gt;&lt;/form&gt; 过滤器 filterfilter 基础 静态网页和动态网页都可以过滤 filter 对于Servlet中的request 和 response 都是同一个对象（内存地址一样） 过滤器的功能： 1234// 1.认证(下载过滤，要登录时，下载的链接放到 request.getSession() 中)// 2.日志与审计// 3.图像转换// 4.压缩 123456public void doGet(request, response)&#123; long start = System.currentMillis(); ... long end = System.currentMillis(); getServletContext().log("cost: " + (end-start));&#125; Filter 接口 12// init(FilterConfig filterConfig)// doFilter(request, response, FilterChain chain) FilterChain 1// doFilter(request, response) 参数没有过滤链了 123456789101112131415161718192021222324// filterimport java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class MyFilter implements Filter&#123; private FilterConfig config; public void destroy()&#123;&#125; public void init(FilterConfig config) throws ServletExcepion&#123; this.config = config; &#125; public void doFilter(ServletRequest req, ServletResponse response res, FilterChain chain) throws ServletException, IOException&#123; // 处理 request chain.doFilter(req, res); // 处理 response &#125;&#125; filter 处理请求乱码123456789public class EncodingFilter implements Filter&#123; public void doFilter(request, response, FilterChain chain) throws ServletException, IOException&#123; request.setCharacterEncoding("UTF-8"); // 千万别忘了 chain.doFilter(request, response) &#125; &#125; filter 组件部署 web.xml配置：过滤器的过滤顺序与在web.xml 中filter-mapping 出现的顺序对应 注解配置：过滤器顺序按照类名的字符串比较规则比较，较小的先执行 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- 一个sevlet 可以分配很多 servlet-mapping ，也就是有多个 url 地址 --&gt;&lt;!-- filter 也可以有多个 filter-mapping --&gt;&lt;web-app&gt; &lt;filter&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;/filter-class&gt;&lt;/filter-class&gt; &lt;!-- 初始化参数，名值对存在 --&gt; &lt;init-param&gt; &lt;param-name&gt;a&lt;/param-name&gt; &lt;param-value&gt;abc&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;&lt;/filter-name&gt; &lt;!-- 过滤 /servert 下的所有网页 --&gt; &lt;!-- *.jpg 可以过滤所有jpg文件--&gt; &lt;url-pattern&gt;/servlet/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;f1&lt;/filter-name&gt; &lt;!-- 只过滤指定servlet --&gt; &lt;servlet-name&gt;s1&lt;/servlet-name&gt; &lt;!-- 用户输入的拦截，容器内派发来的不拦截，默认是这样的，派发的不拦截 --&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;!-- 拦截派发中的 forward(request, response) --&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt; &lt;!-- 拦截派发中的 include(request, response) --&gt; &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt; &lt;!-- 拦截出错的信息 --&gt; &lt;dispatcher&gt;ERROR&lt;/dispatcher&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 过滤器如何写12345678910111213141516171819202122public class AuthFilter implements Filter&#123; // ServletRequest, ServletResponse 处理任何协议 // HttpServletRequest, HttpServletResponse 处理HTTP协议 pubic void doFilter(ServletRequest req, ServletResponse res) throws ServletException, IOException &#123; HttpServletRequest request = (HttpServletRequest) req; HttpServletResponse response = (HttpServletResponse) res; HttpSession session = request.getSession(); String username = (String) session.getAttribute("username"); if(username == null || username.length() == 0)&#123; request.getRequestDispatcher("/login.html"); forward(request, response); return; &#125; chain.doFilter(request, respones); &#125;&#125; 过滤器注解写法多多少少会写一点 12345678910@WebFilter(dispatcherTypes = &#123; DispatcherType.REQUEST, DispatcherType.FORWARD, DispatcherType.INCLUDE, DispatcherType.ERROR &#125;, urlPatterns = ("/TimeFilter"))public class TimeFilter implements Filter&#123; &#125; 过滤器示例1 示例 1234567891011121314151617181920@WebFilter(value = "/*",dispatcherTypes = &#123;DispatcherType.FORWARD,DispatcherType.REQUEST&#125;)...System.out.println("filter---in");filterChain.doFilter(servletRequest, servletResponse);System.out.println("filter---out");...// ---------------------- //@WebServlet("/forward")...System.out.println("/forward");request.getRequestDispatcher("/index.jsp").forward(request, response);...// ------------ //inex.jsp...&lt;% System.out.println("index.jsp"); %&gt;... 执行结果 123456filter---in # 第一次拦截器入栈/forward # ...filter---in # 第二次拦截器入栈index.jsp # ...filter---out # 第二次拦截器出栈filter---out # 第一次拦截器出栈 过滤器示例2 示例 123456789101112131415161718192021222324252627282930@WebFilter(value = "/*",dispatcherTypes = &#123;DispatcherType.FORWARD,DispatcherType.REQUEST&#125;)public class FilterImplA implements Filter &#123;...System.out.println("A---in");filterChain.doFilter(servletRequest, servletResponse);System.out.println("A---out");...// ---------------------- //@WebFilter(value = "/*",dispatcherTypes = &#123;DispatcherType.FORWARD,DispatcherType.REQUEST&#125;)public class FilterImplB implements Filter &#123;...System.out.println("B---in");filterChain.doFilter(servletRequest, servletResponse);System.out.println("B---out");...// ---------------------- //@WebServlet("/forward")...System.out.println("/forward");request.getRequestDispatcher("/index.jsp").forward(request, response);...// ------------ //inex.jsp...&lt;% System.out.println("index.jsp"); %&gt; 执行结果 12345678910A---in # A1入栈B---in # B1入栈/forwardA---in # A2入栈B---in # B2入栈index.jspB---out # B2出栈A---out # A2出栈B---out # B1出栈A---out # A1出栈 过滤器登录验证实例 过滤器 12345678910111213141516171819202122232425// 将req进行强转HttpServletRequest request = (HttpServletRequest) req;// 设置编码request.setCharacterEncoding("utf-8");resp.setContentType("text/html;charset=utf-8");// 获取uriString uri = request.getRequestURI();// 判断uriif(request.getSession().getAttribute("login") != null || uri.contains("/login") || uri.contains("/loginVerifyCodeServlet") || uri.contains("/index.jsp") || uri.contains("/css/") || uri.contains("/js/") || uri.contains("/img/") || uri.contains("/fonts/")) &#123; chain.doFilter(req, resp);&#125; else &#123; ((HttpServletResponse)resp).setStatus(308); request.getRequestDispatcher("/index.jsp").forward(req, resp);&#125; 登录Servlet 12345678910111213public class LoginServlet extends HttpServlet&#123; // 密码一般使用 post 方法传数据 public void doPost(HttpServletRequest request, HttpServletResponse) throws ServletExceptoin, IOException&#123; String username = request.getParameter("username"); String password = request.getParameter("password"); // 明文散列：MessageDigest, MD5, SHA1, SHA256 request.getSession().setAttribute("username", username); &#125;&#125; tomcat 提交数据出现乱码“中国梦” post 12// post 方式不出错, 在body中，服务器不处理// request.getParameter() get 1234// get 方式出错，在header中// 数据包含在 url 中，转换为ascii码，效率低，传输数据少// 一个中文转两个字节(utf-8)// 服务器首先接收到 url 地址，tomcat用iso8859-1转码（一个字节一个字节的转码） 1234567891011121314// 对get请求有效，post应该也有效吧String wd = request.getParameter("wd");wd = new String(wd.getBytes("ISO=8859-1"), "UTF-8")// 方式一，每次都写// 只对post请求有效，对get请求无效// 在setCharacterEncoding 之前，不能执行request.getParameter(), 否则，setCharacterEncoding 无效request.setCharacterEncoding("utf-8");// 方式二，Filter// 对get请求有效// 方式三，在 /config/servlet.xml 中的 Connector 组件中添加 URLEncoding="UTF-8" response.setCharacterEncoding() vs response.setContentType() 123// 一般使用response.setContentType()方法来设置HTTP 响应的编码，同时指定了浏览器显示的编码；// 使用此方法，会自动调用response.setCharacterEncoding()方法来通知浏览器以指定编码来解;// 使用此方法要在response.getWriter()执行之前或response提交之前； get, post乱码请求链接 ServletConfig 读取 web.xml 中的初始化数据12345// javax.servlet.*// javax.servlet.http.* 中已经重写好了String value = getInitParameter("servlet"); init 初始化函数123456789101112// 第一种，重载时不需要调用 super.init(config)public void init() throws ServletException// 最终被 GenericServlet.init(ServletConfig config)调用// 但是 config仍然可以由getServletConfig() 获取// 第二种public void init(ServletConfig config) throws ServletException// 重载时需要调用 super.init(config)// 实现在 Servlet.init(javax.Servlet.ServletConfig)// 综上，推荐使用 init() 课后扩展 如何获取 request 的ip 等信息 URL &amp; URI 1234567uri = request.getRequestURI();// URI = Universal Resource Identifier 统一资源标志符// URL = Universal Resource Locator 统一资源定位符// URN = Universal Resource Name 统一资源名称// URI 包含 URL + URN// 但一般区别不大，技术多用URI// A URI 可以进一步被分为定位符、名字或两者都是. 术语“Uniform Resource Locator” (URL) 是URI的子集, 除了确定一个资源,还提供一种定位该资源的主要访问机制(如其网络“位置”); 明文散列 MessageDigest MD5 SHA1 SHA256 实现关键字过滤 1// 关键字替代为 *** 第一次上机作业12345// servlet// jsp// jquery, ajax// redius// 加载资源文件使用相对地址 第六讲：jsp 类库：javax.servlet.jsp 在服务器运行，输出html到客户端 可以包含动态的js代码，动态的css代码 jsp 文件可以部署，可以声明配置文件 第一次访问jsp 文件慢，第二次就快了，（刷新后又慢了），有以下过程： 1// time.jsp --&gt; time_jsp.java --&gt; time_jsp.class jsp 表达式12&lt;%= 5 + 6 %&gt; // 表达式，不能有分号&lt;%= new String() %&gt; jsp 声明12&lt;%! int i; %&gt; // 一般不声明成员变量，多线程并发危险&lt;%! function() %&gt; // 一般声明函数 jsp 注释1&lt;!-- --&gt; jsp 指令1234567891011// page 指令// session 默认是true，可以不写// 必考：isErrorPage, 默认是false，只有在错误处理页面 /error.jsp 中才是 true&lt;%@ page session="true" %&gt;&lt;%@ page import="java.util.*, java.io.*" // contentType="text/html; charset=utf-8" // 不推荐 contentType, 因为肯定是 html，推荐pageEncoding pageEncoding="utf-8" language="java" isErrorPage="true" errorPage="/error.jsp" // buffer="none" 不推荐none，默认8KB%&gt; 12// include 指令，输出其他文件的内容&lt;$@ include file="a.html" %&gt; 12// 自定义标记，这个指令必考&lt;%@ taglib uri="/WEB-INF/a.tld" prefix="t" %&gt; jsp 动作123&lt;jsp:include page="/servlet/a"&gt;&lt;/jsp:include&gt;// 或者&lt;jsp:include page="/servlet/a" /&gt; 重点重点重点重点重点重点重点重点重点重点重点重点（局部变量创建） 123456789101112&lt;jsp:useBean id="a" class="com.abc.Student" scope="page|request|session|application" /&gt;// page，作用域只在当前页面// request，每次new一个对象// session，作用域session，先访问session，没有新建，写入session// application，共享数据// 相当于 com.abc.Student a// 如果没有，则创建 获取age 12&lt;jsp:getProperty name="a" property="age" /&gt;// 这个name 与 id 一样 重设age 1234&lt;jsp:setProperty name="a" property="age" value="20" /&gt;// 或// 从客户端获取 age，写入变量age， 似乎不需要考虑null&lt;jsp:setProperty name="a" property="age" param="age" /&gt; 匹配 1234567891011&lt;jsp:setProperty name="a" property="*" /&gt; // 根据property和param相同值自动匹配class Student&#123; private age, name, height; public void setAge(int age)&#123;this.age = age;&#125; public int getAge()&#123;return age;&#125;&#125;// 易错 javaBean 首字母全小写&lt;form&gt; &lt;input type="text" name="PageSize" /&gt; // 因为首字母大写，自动匹配时出错,所以要 // &lt;jsp:setProperty name="a" property="pageSize" param="PageSize" /&gt;&lt;/form&gt; include动作 vs include指令 include指令(转换时) 只能包含静态文本文件(html, txt) include动作(运行时) 既能包含静态文件，又能包含动作文件(/servlet/a) jsp 输出信息12345678// 方法一：嵌套now : &lt;%= new java.util.Date() %&gt;// 方法二：引入java代码&lt;% response.getWriter().println("now: "); response.getWriter(java.util.Date());%&gt; jsp 变量(必考)123456789HttpServletRequest requestHttpServletResponse responseHttpSession sessionServletConfig configServletContext application**JspWriter out****PageContext pageContext** // 页面上下文 获取request: pageContext.getRequest();page thisException exception // 正常页面中不存在，只在错误处理页面中存在这个对象 JspWriter vs PrintWriter JspWriter 抛出IOException JspWriter 流缓存满了，再到 response.getWriter()，默认8KB 1&lt;%@ page buffer="none" %&gt; // 没有缓存 pageContext(重点)1234567&lt;%// 法一request.getRequestDispatcher("/b.jsp").forward(request, response);// 法二pageContext.forward("b.jsp");%&gt; 课后扩展设计模式常用的大约20种 fascade 门面模式（要求） adapter 适配器模式（要求） mvc 设计模式（模型，，适配器） mui 设计模式 标记编程el表达式语言 第七讲：自定义标记 将 jsp 中的 java 代码分离出 自定义标记包：javax.servlet.jsp.tagext.*; pageContext 包中的东西一定要会 实例1234567&lt;% numguess.reset(); %&gt;&lt;t: reset /&gt;now: &lt;%= new java.util.Date() %&gt;&lt;t:time&gt;&lt;/t:time&gt; javax.servlet.jsp.tagext123456789101112131415// 初始化void setPageContext(PageContext pc);// 释放（不被销毁），现在又变成销毁的了void release();// 起始标记int doStartTag() throws JspException// 结束标记int doEndTag() throws JspException// 父亲标记Tag getParent()void setParent(Tag t) 实例 1234567891011121314151617181920212223242526import java.io.*;import javax.servlet.*;import javax.servlet.http.*;import javax.servlet.jsp.*;import javax.servlet.jsp.tagext.*;public class TimeTag extends TagSupport&#123; public int doStartTag() throws JspException&#123; // out.println 抛出异常 // 但是不能异常声明，因为是继承的 TagSupport, 原函数就是 throws JspException try&#123; // Fascade 设计模式 JspWriter out = pageContext.getOut(); out.println(new java.util.Date()); &#125;catch(IOException e)&#123; &#125; // return SKIP_BODY; // return EVAL_BODY_INCLUDE; // return SKIP_PAGE; return EVAL_PAGE; &#125;&#125; 返回值 123456// return SKIP_BODY;// return EVAL_BODY_BUFFERED;// return EVAL_BODY_INCLUDE;// return EVAL_PAGE;// return SKIP_PAGE; 将数据写到 request, session 12request: context...get...setAttribute()session: 新版本 tag（tag handler标记处理程序）12345678910111213now: &lt;t:time /&gt;public class TimeTag extends SimpleTagSupport&#123; // SimpleTagSupport 下又 getJspContext(), setJspContext() public void doTag() throws JspException, IOException&#123; // pageContext 变成私有，要读写函数才能访问 // 下面一行错误，getPageContext 处理 http 协议 // getPageContext().getOut().println(new java.util.Date()); // getJspContext() 与协议无关 ((PageContext) getJspContext()).getOut().println(new java.util.Date(); &#125;&#125; 实例 &lt;t:reset&gt; 实现 &lt;% numguess.reset(); %&gt; 的标记 12345678910111213141516import num.NumberGuessBean;public class ResetTag extends SimpleTagSupport&#123; public void doTag() throws JspException, IOException&#123; PageContext pc = (PageContext) getJspContext(); // pc.getSession(); // pc.getOut(); // pc.getAttribute(); // ... NumberGuessBean numguess = (NumberGuessBean) pc.getSession().getAttribute("num"); numguess.reset(); &#125;&#125; 部署 /WEB-INF/a.tld 12345678910111213141516171819&lt;tag-lib&gt; &lt;!-- jar 包，不能在taglib 指令中访问，在这设计，taglib访问 --&gt; &lt;uri&gt;http://www.abc.com/ns/javaee&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;reset&lt;/name&gt; &lt;tag-class&gt;ResetTag&lt;/tag-class&gt; &lt;!-- &lt;body-content&gt;empty&lt;/body-content&gt; 内容设为空，不能有值 --&gt; &lt;!-- &lt;body-content&gt;script&lt;/body-content&gt; --&gt; &lt;!-- 默认jsp --&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;/tag&gt; &lt;/tag-lib&gt; jsp 1234567891011// 命名空间&lt;t:author xmlns="www.zhengxiang4056.club" // 默认命名空间 xmlns:t="http://www.abc.com/ns/book" xmlns:p="wwwwwww.xyz.com" xmlns:p2="www.qixqi.club/iqiq"&gt;// 这个 http://www.abc.com/ns/book 是uri, 不是url, 不是超链接，只要全世界互联网唯一就行，只是命名，随便写，不一定是url // 这样 author实际上就是 http://www.abc.com/ns/book/author&lt;% numguess.reset(); %&gt;&lt;%@ taglib uri="http://www.abc.com/ns/javaee" prefix="t" %&gt; 流程 tag handle 1234567891011121314public class ResetTag extends SimpleTagSupport&#123; public void doTag() throws JspException, IOException&#123; PageContext pc = (PageContext) getJspContext(); // pc.getSession(); // pc.getOut(); // pc.getAttribute(); // ... NumberGuessBean numguess = (NumberGuessBean) pc.getSession().getAttribute("num"); numguess.reset(); &#125;&#125; tld 123456789101112131415161718/WEB/page.tld&lt;tag-lib&gt; &lt;uri&gt;mypage&lt;/uri&gt; &lt;tag&gt; &lt;name&gt;page&lt;/name&gt; &lt;tag-class&gt;PageTag&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;data&lt;/name&gt; &lt;type&gt;java.util.list&lt;/type&gt; &lt;required&gt;true&lt;/required&gt; &lt;!-- true必须提供 --&gt; &lt;!-- run time express value --&gt; &lt;!-- 默认true, true支持动态表达式 --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt;&lt;/tag-lib&gt; jsp 1234&lt;%@ taglib uri="/WEB-INF/page.tld" prefix="x" %&gt;&lt;% &lt;x:page data=&lt;%= list %&gt; &gt; 第三次作业 增删改查放到Service类中 分页程序123456789101112131415161718192021222324252627282930313233343536373839404142434445// PageBean // view// --&gt; s.jsp// --&gt; &lt;jsp:useBean id="page" class="PageBean" scope="session" /&gt;// --&gt; 这里scope 的值是必考的// --&gt; &lt;jsp:setProperty name="page" property="*" /&gt;// jsp 就是展示的，最好不要有业务逻辑public class PageBean&#123; private list data; private int pageSize; private int currentPage; public void setData(List data)&#123; this.data = data; &#125; public void setPageSize(int pageSize)&#123; this.pageSize = pageSize; &#125; public void setCurrentPage(int currentPage)&#123; this.currentPage = currentPage; &#125; public list getCurrentPageData()&#123; int start = pageSize * (currentPage - 1); int end = start + pageSize; if(end &gt; data.size())&#123; end = data.size(); &#125; return data.subList(start, end); &#125; public int getTotalPages()&#123; &#125; public int getNextPage()&#123; return ...; &#125;&#125; 连接池 javax.sql.DataSource 数据库连接 123456789101112131415161718192021import java.sql.*;// Connection// Statement 不建议使用，不安全，慢// PreparedStatement 建议使用// 这一行如果在 service 中，连接过多，大大降低资源// 这一行需要建立连接，很慢Connection conn = DriverManager.getConnection( "jdbc:mysql://localhost:3306/test", "java", "java1234");Driver driverClassName = null;Class.forName(driverClassName);Statement stmt = conn.createStatement("select ...");ResultSet rs = stmt.executeQuery("select ...");PreparedStatement 读取配置文件 1234&lt;!-- jdbc.properties --&gt;driverClassName = com.mysql.jdbc.Driverusername = javapassword = java1234 123456789101112131415161718// 读取文件main()&#123; Properties p = new Properties(); // 不推荐下一行的方法 // InputStream in = new FileInputStream("jdbc.properties"); // 推荐使用 this.getClass().getResourceAsStream("jdbc.properties"); // 加载 p.load(in); // 读取属性 String driverClassName = p.getProperty("driverClassName"); Class.forName(driverClassName); &#125; 连接池 1234&lt;!-- /META-INF/context.xml --&gt;&lt;Context docBase = "" path=""&gt; &lt;Resource name="jdbc/ExamDB" auth="Container" type="javax.sql.DataSource" maxTotal="100" maxIdle="30" maxWaitMillis="1" usernmae="javauser" password="javadude" driver="" url="jdbc:mysql://localhost:3306/javatest" /&gt;&lt;/Context&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.sql.*;import javax.sql.DataSource;import javax.naming.Context;// 创建命名服务// javax.naming.Context cxt = new InitialContext();Context cxt = new InitialContext();// 创建连接池// java:comp/env 前缀，进程内的，辟邪的// java:comp/env 分布式，进程外的，不写前缀 ctx.lookup("jdbc/ExamDB");DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/ExamDB");// apache common dbcpDataSource ds = BasicDataSource();// 法一：静态，最好不用public DBUtils&#123; public static&#125;// 法二：存储在 servletContext// 获取连接池中的连接Connection conn = ds.getConnection();Driver driverClassName = null;Class.forName(driverClassName);Statement stmt = conn.createStatement("select ...");ResultSet rs = stmt.executeQuery("select ...");con.close(); // 释放连接 命名服务 商业包：javax.naming.NamingContext 包: javax.naming.Context 123// lookfor 函数，返回object，需要强制转换// bind 函数，绑定// reBind 函数，重新绑定 123456789101112javax.naming.Context cxt = new InitialContext();DataSource ds = (DataSource) ctx.lookup("java:comp/env/jdbc/ExamDB");Cart cart = new Cart();ctx.bind("/ABC/XYZ/mycart", cart);// 法一Context c1 = (Context) ctx.lookup("/ABC");Context c2 = (Context) c1.lookup("/XYZ");Cart cart = (Cart) c2.lookup("mycart");// 法二Cart cart = (Cart) ctx.lookup("/ABC/XYZ/mycart"); 第八讲：struts 框架a rapid framework for web development based on JavaEE struts 先讲org.apache.struts.actions.DispatchAction(源代码重点) DispatchAction处理函数映射的机制与流程（eg计算器），问答题，详细叙述 1// 类似与 Servlet 中的 service 根据 method 分发为 doGet, doPost 解决控制器类的复用性 Controller 类，降低类的粒度，提高类的可复用性 为什么有复用性问题：modules中 基于 mvc 结构的框架 请求经过：前端控制器、action、后端控制器、module org.apache.struts.action Action 类 前端控制器 org.apache.struts.action.ActionServlet 前端控制器的流程、职责（考试） 后端控制器是单实例的（考试） 前端控制器处理输入数据，封装成 Beans 对象 123// ActionServlet 前端控制器// struts框架主要实现 ActionForward函数// public ActionForward execute Action 123456789101112131415161718192021&lt;web-app&gt; &lt;display-name&gt;Struts Blank Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;!-- 考试题：sturts 项目的配置文件不一定是 struts-config.xml , 可以修改--&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;!-- 获取config, getServletConfig().getInitParameter("config"); --&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;action&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;!-- &lt;url-pattern&gt;/do/delete&lt;/url-pattern&gt; --&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; action 1&lt;action path="/Input" type="org.apache." 课后扩展 jndi 使用 struts 框架的action 做计算器 Java 反射机制：Class, Method calc.add(5, 6) String method = request.getParameter(“method”); Method m = calc.getClass().getMethod(method); m.invoke(m, 5, 6); struts 再讲考试：如何导入一个 struts 工程 controller 控制软件运行的流程，映射成 mapping 建立基于 struts 的web程序 项目结构 12345c:\abc\s1 WEB-INF classes lib web.xml 导入 struts 12345import struts 1, www.apache.org unzip, apps, docs, lib, copy jars to WEB-INF/lib 编辑 web.xml, deploy ActionServlet(Front Controller) 123456789101112131415161718192021222324&lt;!-- web.xml --&gt;&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;s&lt;/servlet-name&gt; &lt;!-- 类名考过，选择题 --&gt; &lt;!-- 命名规范：包名小写，类名大写 --&gt; &lt;servlet-class&gt;org.apache.struts.action.ActionServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 配置信息 --&gt; &lt;!-- struts 配置主要是关于后端控制器的 --&gt; &lt;!-- 读取的信息放到 Map中，key 值是String, 可以根据url地址获取key值 --&gt; &lt;param-name&gt;config&lt;/param-name&gt; &lt;!-- struts 配置文件名可以修改 --&gt; &lt;param-value&gt;/WEB-INF/struts-config.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;s&lt;/servlet-name&gt; &lt;!-- 方式一：&lt;url-pattern&gt;/do/*&lt;/url-pattern&gt; --&gt; &lt;!-- 方式二：使用后缀识别，.do文件类型访问前端控制器 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 前端控制器类如何加载后端控制器类 12345678910111213141516171819ActionServlet&#123; public void service(request, response)&#123; // 方法一，使用 Action Action a = (Action) ...; a.execute(...); // 方法二：不使用 Action, 使用反射机制 Object o = Beans.instantiate()&#123; getClass().getClassLoader(), className // className在配置文件中 &#125;; Method method = o.getClass().getMethod(methodName); method.invoke(a, ...); // 区别 // 方法一：快，眼中依赖 Action，耦合性强(struts1) // 方法二：耦合性弱 &#125;&#125; 写 Action 123456789101112131415161718Action, // Struts 后端控制器的根类：Action类// request 提交处理不了的请求public class AddAction extends Action&#123; public ActionForward execute(ActionMapping mapping,ActionForm form,HttpServletRequest request,HttpServletResponse response) throws Exception&#123; CalcForm form = (CalcForm) form; int i = Integer.parseInt(form.getV1()); // 输入数据 int j = Integer.parseInt(form.getV2()); Calc c = new Calc(); int result = c.add(i, j); form.setResult("" + result); ActionForward r = mapping.findForward("result"); return r; &#125;&#125; struts-config.xml 1234567891011121314151617181920&lt;struct-config&gt; &lt;!-- 不考 --&gt; &lt;formBean&gt; &lt;/formBean&gt;&lt;action-mapping type=""&gt; &lt;action path="/welcome" forward="/welcome.jsp"&gt; &lt;set-property property="example" value="" /&gt; &lt;/action&gt; &lt;!-- add.do 已经在前端控制器类中筛选 --&gt; &lt;action type="AddAction" path="/add" name="calcForm"&gt; &lt;!-- 输出页面 --&gt; &lt;forward name="result" path="result.jsp" /&gt; &lt;/action&gt;&lt;/action-mapping&gt;&lt;/struct-config&gt; CalcForm 类 1234567891011121314public class CalcForm extends ActionForm&#123; // 最好使用 String, 用 int 转换时可能出现前端异常 // 数据处理最好不要让前端处理，逻辑放到后端 private String v1, v2, result; public String getV1()&#123; return v1; &#125; public void setV1(String v1)&#123; this.v1 = v1; &#125; // 提高 public String getV1() 复用性&#125; 提高 public String getV1() 复用性 1234567891011public class DynaActioinForm extends ActionForm&#123; private Map&lt;String, Object&gt; data; public Object get(String name)&#123; return data.get(name); &#125; public void set(String v1, Object value)&#123; map.put(v1, value); &#125;&#125; 降低后端控制器的action org.apache.struts.actions.DispatchAction(源代码重点) 群里代码 DispatchAction 课后扩展 maven 类: Beans.instantiate(); java 的反射机制 struts 后讲 java 资源文件是 properties 123// java.util.ResourceBundle 管理资源包// java.util.ResourceBundle("s4", new Locale("zh", "CN"));// 国际化，多语言显示时，可以写入不同的资源文件，根据地址选择不同的资源文件 代码复用 123// 工具类，业务逻辑// 继承// AOP 编程：在两段代码中，只有一行代码，前后代码复用，可以使用AOP 编程 html 格式 12// 物理格式： 只有一个根元素// 逻辑格式： 应用逻辑决定存在的元素是否合法 (dtd, xsd&lt;类型丰富&gt;文件检查逻辑格式) struts1 和 struts2 的区别(选择题)，网上找一下123456// struts1 Action 函数中有HttpServletRequest, HttpServletResponse// struts2 中没有// struts1 中 ActionForward r = mapping.findForward("result"); return r; // struts2 中 直接返回 return "result"; Action 函数 参数没有 ActionMapping map// struts2 将ActionForm 与 Action 合并在一起// struts2 缺点：多实例， struts1 是单实例的 struts2 的配置文件1&lt;action type="s4.CalcAction" path="calc" method="add" /&gt; 课后扩展 mvc 设计模式 struts commmand命令 jiveforum 软件，汉化过程就是重写资源包 native2ascii 软件，转换文本文件的编码 第九讲：Spring 框架Spring 先讲核心概念：Ioc, AOP 容器，两个对象之间的依赖关系转到对象与容器的依赖关系 Ioc（必考）控制反转 –&gt; 松耦合 DI（必考）: 依赖注入，即组件之间的依赖关系由容器在运行期决定，形象地说，即由容器动态地将某种依赖关系注入到组件之中。 初始化函数与构造函数的区别构造函数创建类的过程中消耗比较多的内存 初始化可多次调用 新建Spring 工程org.springframework.context –&gt; ApplicationContext –&gt; 封装了资源文件 123456789101112131415161718spring frameworkJavaEE platformA a = new A();// 类加载器 getClass().getClassLoader()// java 根类， java.lang.Object// java 源类， java.lang.Class，虚拟机加载几个类，内存中就有几个Class类Object java.beans.Beans.instantiate(ClassLoader c1, String className);A a = new A();Object o = Beans.instantiate(getClass().getClassLoader(), "A") //运行时创建对象，返回ObjectBeanFactory 接口考试：ApplicationContext 接口 FileSystemXmlApplicationContext 类，构造函数，读取xml文件参数，构造 Bean 组件，启动比较慢，可以延迟，没必要，支持多个配置文件，（文件系统）可以使用绝对路径和相对路径，new创建，不可以打包到jar ClassPathXmlApplicationContext 类，比FileSystem推荐使用, 可以归档到jar包，使用ClassLoader.instantiate 创建 创建spring 应该放到 listener 中1&lt;listener 听众接口 servelt.context.listener {servlet init,servlet destory} ContextLoaderListener implements ServletContextListener 读取配置文件中的 listenerlocation12345678910public class ContextLoaderListener implements ServletContextListener&#123; public void contextInitialized(ServletContextEvent sce)&#123; ServletContext cxt = sce.getServletContext(); // 获取 xml 配置文件中的内容 String xmlFile = context.getInitParameter("contextConfigLocation"); XmlWebApplicationContext ac = new XmlWebApplicationContext; &#125;&#125; 声明 listener 和 读取初始化参数 读取servlet 初始化参数12345678910&lt;web-app&gt; &lt;servlet&gt; &lt;servlet-name&gt;a&lt;/servlet-name&gt; &lt;servlet-class&gt;a.AServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;servlet&lt;/param-name&gt; &lt;param-value&gt;www.baidu.com&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;&lt;/web-app&gt; 12345&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- *表示可以多配置文件 --&gt; &lt;param-value&gt;classpath*:/resources/spring/*applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 123456789101112doGet()&#123; String value = getInitParameter("servlet"); // 或者 // HttpServlet 实现了 // 读取Servlet的配置参数 ServletContext/ServletConfig接口 String value = getServletConfig().getInitParameter("servlet"); // 读取整个应用参数 getServletContext().getInitParameter("contextConfigLocation");&#125; AOPSpring 文档 --&gt; 切面（不是面向对象） --&gt; 连接点 --&gt; 切点（集） --&gt; 增强（advance, 执行的关键函数） 简单工厂模式、抽象工厂模式、抽象工厂方法 Spring 再讲理解FileSystemXmlApplicationContext &amp; ClassPathXmlApplication考试：FileSystemXmlApplicationContext 与 ClassPathXmlApplication 加载文件的区别： new FileSystemXmlApplicationContext(“d://beans.xml”); new FileSystemXmlApplicationContext(“beans.xml”); 先读配置文件，需要明确文件在哪 ClassPathXmlApplication 把文件放到Class包中就行，推荐使用，beans.xml 和 class文件放到一起 理解 XmlWebAppnew(启动Web程序，new对象) –&gt; ServletContext 对象 –&gt; ServletContextEvent –&gt; ServletListener(定义的事件处理函数：contextInitialized, contextDestroyed) servletconfig 是加载组件后才生成的 一个 Web 程序就有一个 ServletContext(不考虑分布式) Listener 也是一个组件，客户端不需要访问，不需要Listener-Mapping，也需要部署到 web.xml12345678910111213141516&lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;SpringContextListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;!-- 组件中的 init, 存在 ServletConfig --&gt; &lt;!-- 使用 获取初始化值函数获取 --&gt; &lt;init-param&gt; &lt;param-name&gt;x&lt;/param-name&gt; &lt;param-value&gt;1&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt;&lt;/web-app&gt; 1234567891011121314public interface ServletContextListener&#123; public void contextInitialized(ServletContextEvent sce)&#123; // 命名服务 Context cxt = new InitialContext(); // 本地数据源 DataSource ds = (DataSource)ctx.lookup("java:comp/env/jdbc/ExamDB"); // 将数据源ds存储在 ServletContext // ServletContext sc = (ServletContext) sce.getSource(); // java代码，太过复杂 ServletContext sc = sce.getServletContext(); // j2ee代码，两个等价 &#125; public void contextDestroyed(ServletContextEvent sce)&#123;&#125;&#125; 理解 JavaEE Web Application 集成 struts理解 JaveEE Web Application 如何集成 Spring框架（考试重点，分值大）ContextLoaderListener 实现什么接口 ServletContextListener 如何读取配置文件123456&lt;context-param&gt; &lt;param-name&gt;ServletConfigLocation&lt;/param-name&gt; &lt;!-- classpath: 推荐使用 --&gt; &lt;!-- classpath*: 更慢，谨慎使用，从所有的类加载路径中找spring配置文件，比如jar包--&gt; &lt;param-value&gt;classpath*:/resources/spring/*applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt; 理解Spring framework 配置通常 ApplicationContext.xml123456789101112131415161718192021&lt;beans&gt; &lt;!-- id标识符唯一 --&gt; &lt;bean id="a" class="a.b.c.Hello" /&gt; &lt;!-- name标识符可以重名，不推荐重名 --&gt; &lt;!-- 也可以给同一个bean组件多个名字，不推荐 &lt;bean name="a,b,c" class="" /&gt; --&gt; &lt;bean name="a" class="a.b.c.Hello" /&gt; &lt;!-- bean组件不给命名的话，spring自动命名，小写 &lt;bean class="a.Student" /&gt; --&gt; &lt;!-- 工厂方法创建 bean &lt;bean id="clientService" class="examples.ClientService" factory-bean="serviceLocator" factory-name="createInstance" /&gt; &lt;!-- 使用 examples.ClientService.createInstance函数创建对象 --&gt;(error?) &lt;!-- 加factory-bean后使用 serviceLocator.createInstance创建 --&gt; --&gt;&lt;/beans&gt; bean 的创建可以由构造函数或者延迟创建123456789&lt;beans&gt; &lt;bean id="beanOne" class="x.y.ThingOne"&gt; &lt;contructor-arg ref="beanTwo" type="" name=""/&gt; &lt;contructor-arg ref="beanThree" /&gt; &lt;/bean&gt; &lt;bean class="x.y.ThingTwo" /&gt; &lt;bean class="x.y.ThingThree" /&gt;&lt;/beans&gt; 123456&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;contructor-arg type="int" value="1" /&gt; &lt;contructor-arg type="String" value="fe" /&gt; &lt;/bean&gt;&lt;/beans&gt; 123456&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;contructor-arg name="years" value="1" /&gt; &lt;contructor-arg name="ultimateAnswer" value="fe" /&gt; &lt;/bean&gt;&lt;/beans&gt; 123456&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;contructor-arg name="years" value="1" /&gt; &lt;contructor-arg name="ultimateAnswer" value="fe" /&gt; &lt;/bean&gt;&lt;/beans&gt; setter 方法注入12345678910&lt;beans&gt; &lt;bean id="exampleBean" class="examples.ExampleBean"&gt; &lt;property name="beanOne"&gt; &lt;ref bean="anotherExampleBean" /&gt; &lt;/property&gt; &lt;property name="beanOne" rel="anotherExampleBean" /&gt; &lt;/bean&gt;&lt;/beans&gt; java 注解实现bean 配置12345@Configurationpublic class AppConfig&#123; @Bean("myBean", scope="") ...&#125; Spring配置连接池123456&lt;bean id="" destroy-method="close"&gt; &lt;property name="" value=""/&gt; &lt;property name="" value=""/&gt; &lt;property name="" value=""/&gt; &lt;property name="" value=""/&gt;&lt;/bean&gt; xml 属性 or 子元素推荐使用子元素，唯一性的子元素最好使用属性1234&lt;student id="201792179"&gt; &lt;name&gt;郑翔&lt;/name&gt; &lt;grade&gt;3&lt;/grade&gt;&lt;/student&gt; ApplicationContext获取 ApplicationContext 全局静态变量 Aware 接口，只有一个函数 也可以凭借 DI 123public void setApplicationContext(ApplicatoinContext act)&#123; this.ApplicationContext = act;&#125; 1234567public interface ApplicationContextAware&#123; public void setApplicationContext(ApplicatoinContext act)&#123; this.ApplicatoinContext = act; &#125; public static getApplicatoinContext&#125; WebApplicatoinContextUtils 工具类中的函数都是静态的 bean对象的作用域默认是单例模式，只有一个实例 singleton vs prototype 必考 1234567&lt;bean id="" class="", scope="" /&gt;&lt;!-- singleton 单例 --&gt;&lt;!-- prototype 模型 --&gt;&lt;!-- request --&gt;&lt;!-- session --&gt;&lt;!-- application --&gt;&lt;!-- --&gt; spring配置文件1234567891011&lt;context:annotation-config /&gt;&lt;!-- 可以不写 --&gt;&lt;context:component-scan base-package="" /&gt;&lt;!-- 扫描 --&gt;&lt;!--spring对配置文件的加载--&gt;&lt;context:property-placeholderlocation="classpath:jdbc.proerties" /&gt;&lt;!-- 最多出现一次 --&gt;&lt;!-- 加载多个 class="org.springframework.beans.factory.config.Properties" --&gt;&lt;!--注解，在Bean中注入--&gt;&lt;!--@Value("$&#123;abc&#125;")，自动完成类型转换 --&gt;&lt;!--private String abc;--&gt; Spring mvcmvc设计模式，具有图形的应用程序，视图与业务逻辑 控制器的主要功能时 Mapping，控制视图和业务逻辑的映射 123456789&lt;web-app&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoader&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLoaction&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/conf/spring.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 12345678// 读取 context-param 中的spring配置文件public class ContextLoaderListener implements ServletContextLoader&#123; public void contextInitialized(ServletContextEvent sce)&#123; String filename = sce.getServletContext().getInitParameter("contextConfigLocation"); // Servlet, ServletConfig, HttpServlet, ServletContext &#125;&#125; web.xml 中导入前端HttpServlet 实现 Servlet接口和 ServletContext接口 12345678910111213141516171819202122232425&lt;!-- web.xml --&gt;&lt;!-- 这个子元素必须有，Servlet容器新增加的特性，支持多模块开发 --&gt;&lt;absolute-ordering /&gt;&lt;servlet&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.Dispatcher&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;&lt;/param-value&gt; &lt;!--&lt;param-value&gt;/WEB-INF/spring.xml&lt;/param-value&gt;--&gt; &lt;!--多个配置文件一&lt;param-value&gt;/WEB-INF/*.xml&lt;/param-value&gt;--&gt; &lt;!--多个配置文件二&lt;param-value&gt;/WEB-INF/a.xml, /WEB-INF/b.xml&lt;/param-value--&gt; &lt;!--使用类路径即class文件夹&lt;param-value&gt;classpath:a.xml&lt;/param-value&gt;--&gt; &lt;!--使用类路径&lt;param-value&gt;classpath*:a.xml&lt;/param-value&gt;不推荐使用--&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;!-- servlet 可以映射给多个 url --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;!--拦截所有 &lt;url-pattern&gt;/&lt;/url-pattern&gt; --&gt; &lt;/servlet-mapping&gt;&lt;/servlet-mapping&gt; 对比配置文件业务逻辑层，不与视图有关1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLoaction&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/conf/spring.xml&lt;/param-value&gt;&lt;/context-param&gt; 与视图有关1234&lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/spring.xml&lt;/param-value&gt;&lt;/init-param&gt; 两者配置一个就行，老师推荐使用前者（好像是） servlet 映射中的映射优先级下降顺序（易错 /*优先级更高） a.html /* /*.html / / 和 /* 的区别tomcat/conf/web.xml 前端控制器下123456789101112&lt;servlet-mapping&gt; &lt;servlet-name&gt;app&lt;/servlet-name&gt; &lt;!-- 这里如果时/* 的话，由于 /* 的优先级比 tomcat/conf/web.xml 中的*.jsp的优先级高，前端控制器会拦截jsp文件，这样tomcat就不会处理jsp文件，把jsp文件当作静态资源返回给客户端，不会解析jsp文件，这样客户端显示的就是jsp源码 --&gt; &lt;!-- 方式一 --&gt; &lt;!-- 由于 /的优先级最低，这样jsp又可以解析了 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;!-- 方式二 --&gt; &lt;!-- 创建子文件夹 --&gt; &lt;url-pattern&gt;/app/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 如何访问静态资源，不让前端控制器起作用123&lt;mvc:resource mapping="/js/**" location="/js/" /&gt;&lt;!-- 由于 url-pattern 是 /，则WEB-INF/下的静态资源访问需要这样 --&gt;&lt;mvc:resource mapping="/css/**" location="/WEB-INF/css/" /&gt; 视图层不应该直接访问，给一个逻辑名，比如 a.jsp，由*.do拦截访问（似乎是这样） * 和 ** 的区别子文件夹下1&lt;mvc:resource mapping="/js/**" location="/js/" .&lt; spring后端控制器spring 配置文件12345&lt;!-- 开启mvc --&gt;&lt;mvc:annotation-driven /&gt;&lt;!-- 扫描器 --&gt;&lt;context:compontent-scan base-package="com.abc.project.controller" /&gt; 123456789101112131415161718// 这种方式不太好package com.abc.project.controller;@Controller// 模块开发@RequestMapping("/calc")public class MyController&#123; @RequestMapping("/add") // 这里 v1必须与什么一样，不然不给你笨蛋注入 public String add(String v1, String v2)&#123; &#125; @RequestMapping("/substract") public String substract(String v1, String v2)&#123; &#125;&#125; 12// 这种方式比较好下课补吧，泪哭 后端控制器返回对象(8个)1public void add(Locale locale, HttpSession session, HttpServeltRequest request, HttpServletResponse response) session request response locale 国家地区，国际化网页 后端控制器注解java.util.Locale@PathVariable 获取数据 @RequestParam @RequestHead @RequestBody 对象与json的转换 @RequetMapping 返回数据 @ResponseBody // 将对象转换为 json返回，编码 ISO8859-1(美国国际编码)public @ResponseBody List a(String a){ }1234&lt;!-- spring配置文件修改 ISO8859-1 为 UTF-8 --&gt;&lt;mvc:annotation-driven&gt; &lt;mvc:message-&lt;/mvc:annotation-driven&gt; 不同的请求方法@GetMapping, @PostMapping, @PutMapping, @DeleteMapping 这些都等价于 @RequestMapping ，只是请求方法各异 Controller 与 RestControllerRestController 不需要再用 RequestBody, ResponseBody RestController 返回的都是对象 Object @RequestParam(value=”v1”) 与 @Request(“v1”)两者等价，因为默认值是 value，设置其他属性就不一样了 spring 对路径灵活模版路径 – 带动态参数的路径 @RequestMapping(“/student/{studentid}/modify”) @RequestMapping(“/student/modify/{studentid}”) spring 注入spring 是注入技术 123public String a(HttpServletResponse res, HttpServletRequest req)&#123; // res和req的顺序没问题&#125; Spring 可以将html form表单提交的数据放入 Map中 自己做框架 spring 视图技术 View接口，派发出一堆东西，比如 JSONView, PdfView, ExcelView, 也可以自己写DownloadView 上传文件，给文件一个不重的随机数修改文件名，源文件名与新文件名放入Model,下载时查找Model，找到要下载的文件 将文件名与id存入数据库并将文件名修改id，下载时根据文件名到数据库查找id，找到文件的真实 url 企业自己写View，不如DownloadView json 面向对象编程 Spring 后讲spring mvc 支持的视图技术：freemarker, jsp, groovy, markup jsp 视图技术需要下载 jstl-1.2.jar123456&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.In" &lt;property name="viewClass" value="org.springframework." /&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt;/&gt; 控制器只需要返回视图的逻辑名称 如果 controller 什么逻辑也不执行，仅仅是转发到某个试图1&lt;mvc:view-controller path="/jsp/a" view-name="a" /&gt; 现在不能直接访问 jsp文件 a.jsp –&gt; /jsp/a JSP 的视图类org.springframework.web.servlet.view.InternalResourceViewResolver 实现了View, BeanNameAware, ApplicationContextAware, ServletContextAware 接口 ServletContextAware: View 知道WEB容器 ApplicationContextAware: View 知道WEB应用接口，知道应用下的所有组件 自定义视图时要实现这几个接口 视图解析spring 支持多个viewresolve @Nullable 考试：org.springframework.web.servlet.View 接口中声明的两个抽象函数 123@Nullable // 返回值允许为空，spring提供默认类型public default String getContentType();public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception interface 中的 defaultjava8 后允许接口中实现函数123456public interface K&#123; public default void a()&#123; // public 和 default可以位置互换 &#125; void b();&#125; 范型123// 具体明确List&lt;String&gt; list = new ArrayList&lt;String&gt;();String s = list.get(0); // 不需要类型转换，默认好似 Object 1234567891011// 语法错误，不明确Map&lt;String, Object&gt; map = new HashMap&lt;String, Student&gt;();Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();// ? 匹配任何类型Map&lt;String, ?&gt; map = new HashMap&lt;String,?&gt;();上界 下界&lt;String, ?, extend= &gt;&lt;String, ?, super= &gt; DownloadView1234567891011public class DownloadView implements View, ApplicationContextAware, ServletContextAware, BeanNameAware&#123; @Override public String getContentType()&#123; return "application/x-download; charset=utf-8"; // return "application/json; charset=utf-8" &#125; @Override *考试：Map&lt;String, ?&gt; 参数的优点和缺点* public void render(Map&lt;String, ?&gt; model, HttpServletRequest)&#125; jsonView文件类型 .html .php http://localhost:8080/hello?format=xml Ordered 接口spring 支持 viewresolver, 使用 order（优先级，整数，值越小优先级越高，0最高） modelmodel.addAttribute(“username”, list); ${list[2]} ${list.key} // Map ${list.key[2]} // Map 的value 时数组 前端 –&gt; 拦截器预处理 –&gt; Controller –&gt; ModelAndView –&gt; 拦截器后处理 –&gt; resolveview –&gt; view native2ascii pdfView, XMlView, jsonView 写 excelView 最后一讲spring jdbc 提供了jdbc操作的进一步封装 org.springframework.jdbc.core.JdbcTemplate 类 对象到关系数据库的映射： O/R Mapping 对象关系映射， Hibernate, MyBatis Hibernate 慢，不能处理复杂sql语句，MyBatis 快，JDU 效果不好,没有使用反射机制（快，不好） 使用 org.springframework.jdbc 就够了 spring dao 类 1Bag&lt;Apple&gt;b = new Bag&lt;RedApple&gt;(); // 语法错误，范型意味着类型明确，前后不会类型转换，类型不一致 写 MySevice 函数 学习 MyBatis]]></content>
      <categories>
        <category>Java</category>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J2EE</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[manjaro 安装后配置]]></title>
    <url>%2F2019%2F05%2F12%2Fmanjaro%2F</url>
    <content type="text"><![CDATA[同步远程数据包到本地没有同步数据包的话，安装软件时可能会出现数据包找不到的 warning，终端执行 1sudo pacman -Syy 安装 vimvim 无疑是linux下最好用的编辑器，不是很熟悉vim 的可以终端执行 1vimtutor 获取 《VIM 教程》，讲述了一些必要的基本命令，效果还可以，接下来假定你已经会使用 vim编辑器，如果实在不想学习vim，可以使用一些其他的编辑器，如 nano，也是很方便 安装 vim 1sudo pacman -S vim 添加 archlinuxCN 源编辑 pacman.conf 配置文件 1sudo vim /etc/pacman.conf 在底部添加(连续按’GG’就可以跳转到文章尾)： 123[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/$arch 然后终端执行，更新数据包 1sudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring 更新1sudo pacman -Syu 这一下更新包较多，大概1.5G MacBook Air 安装 Manjaro 不能连接无线网Mac 使用的是博通的网卡，需要自己安装无限网卡驱动，可以使用 “inxi -F” 查看自己的网卡型号 1234Network: Device-1: Broadcom and subsidiaries BCM4360 802.11ac Wireless Network Adapter driver: wl IF: wlp3s0 state: up mac: d0:81:7a:be:dd:80 我的网卡型号时 BCM4360 先连接有线网，sudo pacman -Syu 更新系统，然后在系统设置里找到内核，查看内核版本，选择与内核版本匹配的linux-headers，如我正在运行的内核是 Linux 4.19.36-1，选择 linux419-headers安装 1sudo pacman -S linux-headers 或者 yaourt linux-headers 最后安装无线网卡驱动 1sudo pacman -S broadcom-wl-dkms 重启，ok 安装搜狗输入法Manjaro 下有很多可以选择的输入法，如搜狗、谷歌，个人感觉搜狗更加贴切国内用户的使用 123sudo pacman -S fcitx-sogoupinyinsudo pacman -S fcitx-im # 全部安装sudo pacman -S fcitx-configtool # 图形化配置工具 然后配置中文输入发环境变量，编辑 ~/.xprofile文件（如果不存在，则新建），添加： 123export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS="@im=fcitx" 重启后就可以正常使用了 安装常用软件安装 yaourt &amp; yay1sudo pacman -S yaourt yay 安装 git1sudo pacman -S git 设置个人 github 信息12git config --global user.name "github用户名"git config --global user.email "注册邮箱" 安装 zsh – shell中的极品安装 zsh (需要先把 git 安装好) 1sudo pacman -S zsh 配置 oh-my-zsh 1sh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)" 更换默认的shell 1chsh -s /bin/zsha 安装 chromiumchromium 是开发者版的谷歌浏览器，更新较为频繁 1sudo pacman -S chromium 安装网易云音乐桌面版： 1sudo pacman -S netease-cloud-music 终端版：musicbox 1yaourt musicbox 安装完后终端键入 musicbox 就可以体验终端版的网易云了 安装 WPS12sudo pacman -S wps-officesudo pacman -S ttf-wps-fonts # 安装wps字体 安装微信1sudo pacman -S electronic-wechat 安装 ssr1sudo pacman -S shadowsocks-qt5 安装坚果云1sudo pacman -S nutstore 安装 VScode1sudo pacman -S visual-studio-code-bin 安装主题Warning: kde桌面 12sudo pacman -S papirus-icon-themesudo pacman -S arc-kde kvantum-theme-arc 安装完成之后可以到设置里更改使用 安装 uget1sudo pacman -S uget aria2 chrome 启用 uget 下载打开 uGet 选择 编辑 -&gt; 设置 -&gt; 插件，然后把插件匹配顺序改为：aria2 然后安装 chrome 浏览器插件 12sudo pacman -S uget-intedratorsudo pacman -S uget-intedrator-chrome 安装 pycharm professional1sudo pacman -S pycharm-professional 破解。。。后续 安装 typora1sudo pacman -S typora 安装 PS 替代品 —— gimp1sudo pacman -S gimp 安装 flash12sudo pacman -S pepper-flashsudo pacman -S flashplugin 配置：后续。。。 安装 mysql 安装 mysql1sudo pacman -S mysql 初始化1sudo mysqld --initialize --user=mysql --basedir=/usr --datedir=/var/lib/mysql 执行结束后默认创建一个 SQL 用户：root 以及 root用户密码 开机自启1sudo systemctl enable mysqld.service 启动 MySQL 服务12sudo systemctl start mysqld.service # 启动sudo systemctl status mysqld.service # 查看状态 连接数据库1mysql -uroot -p 输入刚才生成的 root 密码 修改 root 密码首先要连接数据库，然后根据 mysql 版本键入命令 mysql 8 1ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'; mysql 8.0 以下 1ALTER user 'root'@'localhost' IDENTIFIED BY '新密码'; 后续mysql 身份验证问题，mariaDB的替换 安装 mycli由于 mysql 在使用过程不提示命令，mycli就可以很好地解决这一点 1sudo pacman -S mycli 但在MySQL 下，mycli 插件无法使用了，首先要确保 PyMySQL &gt;= 0.6.7 1pip install pymysql 安装 mysql workbench数据库可视化也是很人性化的 1sudo pacman -S mysql-workbench Manjaro 下 mysql 巨坑Manjaro 每次更新的时候，mysql 都有可能崩溃，因为更新的时候说不定哪个库或者依赖更新，而mysql没有及时更新都会造成 mysql 无法启动成功，很是头疼，正在考虑其他数据库 /(ㄒoㄒ)/~~ 安装 gpick 取色工具1sudo pacman -S gpick 安装 redshift-gtk 护眼神器1sudo pacman -S redshift # 或者 sudo pacman -S redshift-gtk 在系统设置设置自动启动就可以每次开机连接网络后自动开启护眼模式了 安装 pipManjaro 默认是有 pip的 123sudo pacman -S wgetwget https://bootstrap.pypa.io/get-pip.pysudo python get-pip.py 安装 virtualbox坑太多，后续。。。 更新后解决搜狗输入法乱码1sogou-qimpanel 提示找不到依赖库，重新建立软链接 1sudo ln -s /usr/lib64/libidn.so.12.6.0 /usr/lib64/libidn.so.11 pacman 常用命令12345678910pacman -S # 安装pacman -R # 删除pacman -Rs # 移除已安装不需要软件包pacman -Rsc # 删除一个包，所有依赖pacman -Syu # 升级包pacman -Ss # 查询包数据库pacman -Qs # 搜索已安装的包pacman -Si # 显示包大量信息pacman -Qi # 本地安装包pacman -Sc # 清理包缓存 Manjaro 搭建 Apache、Mysql、PHP 环境安装 Apache1sudo pacman -S apache 查看 Apache 状态和版本信息 12sudo systemctl status httpdapachectl -v # 或者 httpd -v 设置开机启动 12sudo systemctl enable httpdsudo systemctl restart httpd 站点根目录 1cd /srv/http/ 安装 Mysqla跳转 md跳转 安装 PHP1sudo pacman -S php php-apache 修改 apache 配置 1sudo vim /etc/httpd/conf/httpd.conf 注释掉 1LoadModule mpm_event_module modules/mod_mpm_event.so 去掉注释 1LoadModule mpm_prefork_module modules/mod_mpm_prefork.so 在末尾添加 123LoadModule php7_module modules/libphp7.soAddHandler php7-script phpInclude conf/extra/php7_module.conf 测试 php 1sudo vim /srv/http/test.php 键入php代码 123&lt;?php phpinfo();?&gt; 重启 apache 1sudo systemctl restart httpd 浏览器访问 http://localhost/test.php 安装 phpMyAdmin与 mysql workbench 类似，phpMyAdmin也是将数据库图形化，优点是浏览器访问，可以跨平台使用，也可以用在服务器端的数据库 1sudo pacman -S phpmyadmin 编辑 php 配置文件 1sudo vim /etc/php/php.ini 确认接下来几行没有被注释掉 1234[...]extension=bz2.so # 我的是 extension=bz2extension=mysqli.so # extension=mysqli[...] 然后，创建 phpmyadmin的配置文件 1sudo vim /etc/httpd/conf/extra/phpmyadmin.conf 添加： 1234567Alias /phpmyadmin "/usr/share/webapps/phpMyAdmin"&lt;Directory "/usr/share/webapps/phpMyAdmin"&gt;DirectoryIndex index.phpAllowOverride AllOptions FollowSymlinksRequire all granted&lt;/Directory&gt; 然后，打开 apache 配置文件 1sudo vim /etc/httpd/conf/httpd.conf 末尾添加： 1Include conf/extra/phpmyadmin.conf 重启 apache 1sudo systemctl restart httpd 测试 phpmyadmin http://localhost/phpmyadmin 进入主界面如果在底部出现error: “The configuration file now needs a secret passphrase (blowfish_secret)” ，编辑 1sudo vim /etc/webapps/phpmyadmin/config.inc.php 找到以下代码并编辑 1$cfg['blowfish_secret'] = '`MyP@$S`'; /* YOU MUST FILL IN THIS FOR COOKIE AUTH!$ /** 重启 apache 1sudo systemctl restart httpd 坑，后续。。。 Manjaro 使用 Wine安装配置 Wine1sudo pacman -S wine wine_gecko wine_mono 配置 64 &amp; 32 位环境 123mv ~/.wine ~/.wine64# 使用WINEARCH建立32位环境配置WINEARCH=win32 WINEPREFIX=~/.wine winecfg 安装32位显卡驱动 1sudo pacman -S lib32-mesa lib32-nvidia-utils 设置字体https://blog.csdn.net/zbgjhy88/article/details/85110956 后续。。。 运行 Windows 应用1wine exe文件名 安装 Windows 应用1msiexec -i msi安装包 卸载应用1wine uninstaller wine 菜单管理wine 中安装的应用可以在系统菜单中以 Wine 子菜单的形式呈现 后续。。。 Deepin-WineDeepin-Wine 是国产操作系统 Deepin 移植的Wine，对国内软件，有着更好的兼容性和使用体验 Warning: Deepin-Wine 32位 1sudo pacman -S deepin-wine 安装 exe程序 1deepin-wine QQBrowser.exe 打开注册表 1deepin-wine regedit bash 脚本自己根据自己环境配置编写的 shell 文件，能够比较快捷简单的配置环境 manjaro.sh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277#!/bin/bash# manjaro 安装后配置以及软件安装# 同步远程数据库到本地sudo pacman -Syy# 安装 vimsudo pacman -S vim# 添加 archlinuxCN 源sudo echo "[archlinuxcn]SigLevel = Optional TrustedOnlyServer = https://mirrors.ustc.edu.cn/archlinuxcn/\$arch" &gt;&gt; /etc/pacman.confsudo pacman -Syy &amp;&amp; sudo pacman -S archlinuxcn-keyring# 更新sudo pacman -Syu# MacBook Air 安装无线网卡驱动read -p "If your computer can connect to the wireless network(Y/N): " CONNcase "$CONN" in [yY] | [yY][eE][sS]) echo "Ok, you are lucky :)" ;; [nN] | [nN][oO]) echo "Sad, there are another packets you need to install :(" read -p "If your system kernel is 4.19 and your network card model is Broadcom 4360(Y/N): " KERNEL case "$KERNEL" in [yY] | [yY][eE][sS]) echo "Good Luck :)" sudo pacman -S linux419-headers broadcom-wl-dkms echo "Everything will be ok after reboot ..." read -p "If you want to reboot to use wireless network now(Y/N): " WIRELESS case "$WIRELESS" in [yY] | [yY][eE][sS]) echo "reboot ..." reboot ;; [nN] | [nN][oO]) echo "That's Ok, but you cannot use wireless network until reboot" ;; *) echo "Invalid answer :/" ;; esac reboot ;; [nN] | [nN][oO]) echo "Sad, now I cannot resolve it ...." echo "But I will resolve soon" ;; *) echo "Invalid answer :/" ;; esac ;; *) echo "Invalid answer :/" ;;esac# 安装搜狗输入法sudo pacman -S fcitx-sogoupinyin fcitx-im fcitx-configtoolsudo echo "export GTK_IM_MODULE=fcitxexport QT_IM_MODULE=fcitxexport XMODIFIERS=\"@im=fcitx\"" &gt;&gt; ~/.xprofileread -p "If you want to reboot to use sogoupinyin now(Y/N): " CHOOSEcase "$CHOOSE" in [yY] | [yY][eE][sS]) echo "reboot ..." reboot ;; [nN] | [nN][oO]) echo "Ok, but you cannot use sogoupinyin until reboot" ;; *) echo "Invalid choose :/" ;;esac# 安装常用的软件sudo pacman -S yaourt yay git zsh chromium netease-cloud-music wps-office ttf-wps-fonts electronic-wechat shadowsocks-qt5 nutstore uget aria2 pepper-flash flashplugin redshift# 安装软件配置编程环境read -p "If you want to configure programming environment(Y/N): " CODEcase "$CODE" in [yY] | [yY][eE][sS]) echo "You must be a qualified programmer :)" sudo pacman -S visual-studio-code-bin pycharm-professional typora gimp gpick ;; [nN] | [nN][oO]) echo "Your work must be more comfortable than me :(" ;; *) echo "Invalid answer :/" ;;esac# 设置 github 信息read -p "If you want to set your github info now(Y/N): " GITHUBcase "$GITHUB" in [yY] | [yY][eE][sS]) read -p "Enter your github username: " GITHUB_USERNAME read -p "Enter your github registered email: " GITHUB_EMAIL git config --global user.name "$GITHUB_USERNAME" git config --global user.email "$GITHUB_EMAIL" echo "success to your github info" ;; [nN] | [nN][oO]) echo "Ok, you can set it yourself later" ;; *) echo "Invalid answer :/" ;;esac# 配置 zshsh -c "$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)"chsh -s /bin/zsha# 安装 musicboxread -p "If you want to try musicbox(netease-cloud-music on terminal)(Y/N): " MUSICBOXcase "$MUSICBOX" in [yY] | [yY][eE][sS]) yaourt musicbox echo "input \"musicbox\" in terminal, then you can have a try" ;; [nN] | [nN][oO] echo "Unfortunately, you miss a chance to \"装B\"" ;; *) echo "Invalid choose :/" ;;esac# 安装主题read -p "If your stystem is kde desktop(Y/N): " DESKTOPcase "$DESKTOP" in [yY] | [yY][eE][sS]) read -p "Would you like to try another theme of your system(Y/N): " THEME case "$THEME" in [yY] | [yY][eE][sS]) sudo pacman -S papirus-icon-theme arc-kde kvantum-theme-arc echo "success to theme" echo "You can choose the theme in system settings" ;; [nN] | [nN]) echo "That's OK" ;; *) echo "Invalid answer :/" ;; esac ;; [nN] | [nN][oO]) echo "That's OK" ;; *) echo "Invalid answer :/" ;;esac# 安装 mariadbread -p "If you want to install mysql(mariadb is better in Manjaro)(Y/N): " MARIADBcase "$MARIADB" in [yY] | [yY][eE][sS]) sudo pacman -S mariadb mycli mysql-workbench sudo mysqld --initialize --user=mysql --basedir=/usr --datedir=/var/lib/mysql read -p "If you want to start mysql when boot up: " MYSQL_START case "$MYSQL_START" in [yY] | [yY][eE][sS]) sudo systemctl enable mysqld.service ;; esac sudo systemctl start mysqld.service echo "success to install mysql" echo "change mysql password by this: " echo "ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '新密码'; " ;; [nN] | [nN][oO]) echo "That's Ok" ;; *) echo "Invalid answer :/" ;;esac# 搭建 Apache、PHP 环境read -p "If you want to configure the environment with Apache and PHP(Y/N): " APcase "$AP" in [yY] | [yY][eE][sS]) sudo pacman -S apache phpmyadmin read -p "If you want to start Apache when boot up: " APACHE_START case "$APACHE_START" in [yY] | [yY][eE][sS]) sudo systemctl enable httpd ;; esac sudo systemctl restart httpd echo "success to apache, and the location of site is /srv/http/" sudo pacman -S php php-apache echo "修改/etc/httpd/conf/httpd.conf 文件" sudo pacman -S phpmyadmin echo "编辑/etc/php/php.ini 文件" echo " Alias /phpmyadmin \"/usr/share/webapps/phpMyAdmin\" &lt;Directory \"/usr/share/webapps/phpMyAdmin\"&gt; DirectoryIndex index.php AllowOverride All Options FollowSymlinks Require all granted &lt;/Directory&gt;" &gt;&gt; /etc/httpd/conf/extra/phpmyadmin.conf echo " Include conf/extra/phpmyadmin.conf" &gt;&gt; /etc/httpd/conf/httpd.conf sudo systemctl restart httpd echo "访问 http://localhost/phpmyadmin" ;; [nN] | [nN][oO]) "That's OK, you can configure youself later if you want" ;; *) echo "Invalid answer :/" ;;esac# 使用 Wineread -p "If you want to use wine to run windows software(Y/N): " WINEcase "$WINE" in [yY] | [yY][eE][sS]) sudo pacman -S wine wine_gecko wine_mono mv ~/.wine ~/.wine64 WINEARCH=win32 WINEPREFIX=~/.wine winecfg sudo pacman -S lib32-mesa lib32-nvidia-utils read -p "If you want to use Deepin-Wine(Y/N): " DEEPIN_WINE case "$DEEPIN_WINE" in [yY] | [yY][eE][sS]) sudo pacman -S deepin-wine ;; esac ;; [nN] | [nN][oO]) echo "That's Ok" ;; *) echo "Invalid answer :/" ;;esac# 实现简单的图形界面# 实现安装过的跳过# 实现自动读取系统信息，配置个性化环境# 如何获取最小权限修改只读文件# 前序工作：# chmod 755 manjaro.sh# sudo ./manjaro.sh]]></content>
      <categories>
        <category>Manjaro</category>
        <category>beautify</category>
      </categories>
      <tags>
        <tag>Manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr 搭建ssr/bbr加速]]></title>
    <url>%2F2019%2F04%2F28%2Fssr-creat%2F</url>
    <content type="text"><![CDATA[创建Vultr账号现在vultr有活动，注册领取25美金，💰vultr ，可以使用好几个月了，要是再拉几个小伙伴，一起越狱，那就更舒服了。 首先，访问 vultr ，创建vultr账号（注意要验证邮箱，否则搭建不了服务器）。 然后，阿里支付，vultr可以直接使用阿里支付和微信支付，还是比较好的， 最低支付为10美元，可以用两个月了 搭建Vultr服务器选择服务器，个人感觉洛杉矶的挺好的 选择系统，由于我的腾讯云服务器安装的centos，比较熟悉，这里我就选择centos吧，你当然可以选择ubuntu等 Server Size: 选择5美元的，每个月1个T，绰绰有余了，网速还可以 额外的功能，选上 “Enable IPv6” 和 “Enable Private Networking” 只要免费就选上啊😄 最后，选择 Server HostName 稍等两分钟，服务器便搭建成功了 安装xshellManjaro/linux 使用sshMac 和 linux 系统一般自带 ssh windows 使用ssh目前，手头咩有windows系统，过几天再说 安装 openssh 后就可以在windows命令行上使用 ssh, scp 命令了 没安装 openssh 的小伙伴，软件挂在 upload ，第42个文件 然后一路高歌猛进，默认安装即可 检查安装是否成功：”windows” + R &gt;&gt; cmd &gt;&gt; 输入ssh / scp 不报错就完成安装了 搭建SSR服务查看服务器ip和root密码 然后Linux/Mac 打开终端连接服务器 12ssh root@你的服务器ip(然后根据交互过程输入密码) 连接服务器成功后，下载脚本 1git clone -b master https://github.com/flyzy2005/ss-fly 然后运行脚本 1ss-fly/ss-fly.sh -ssr 然后，根据交互过程填写端口，密码，加密方式，协议，混淆等，也可以一直按回车默认。 相关ssr操作 1234567/etc/init.d/shadowsocks start # 启动/etc/init.d/shadowsocks stop # 停止/etc/init.d/shadowsocks restart # 重启/etc/init.d/shadowsocks status # 状态/etc/shadowsocks.json # 配置文件/var/log/shadowsocks.log # 日志文件/usr/local/shadowsocks # 代码安装目录 卸载ssr服务 1./shadowsocksR.sh uninstall 开启BBR服务现在已经成功配置了SSR服务，可以用来查找谷歌资料了，但是速度方面还是有些慢 开启BBR服务，可以有效提高速度，在刚才的目录下 1ss-fly/ss-fly.sh -bbr 装完后需要重启系统 重启完后，重新连接服务器，执行 1sysctl net.ipv4.tcp_available_congestion_control 如果显示为 1net.ipv4.tcp_available_congestion_control = bbr cubic reno 顺序不重要，只要有bbr 就行 SSR地址Windows 客户端: https://github.com/shadowsocks/shadowsocks-windows/releases Mac 客户端：https://github.com/shadowsocks/ShadowsocksX-NG/releases Linux 客户端：https://github.com/shadowsocks/shadowsocks-qt5/wiki/Installation Android 客户端: https://github.com/shadowsocks/shadowsocks-android/releases iOS 客户端: 应用商店(美区Apple ID) shadowsocks下载 感谢：https://www.2cto.com/kf/201808/764719.html]]></content>
      <categories>
        <category>SSR</category>
      </categories>
      <tags>
        <tag>SSR</tag>
        <tag>Vultr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo blog 美化升级]]></title>
    <url>%2F2019%2F04%2F19%2Fhexo-beautify%2F</url>
    <content type="text"><![CDATA[1&#123;% aplayer "Way Back Home" "SHAUN" "https://qixqi.club/audio/homeway.mp3" "https://qixqi.club/images/zhaolei1.jpeg" %&#125; 1&#123;% dplayer "url=https://qixqi.club/video/dingning.mp4" "pic=https://qixqi.club/images/zhaolei1.jpeg" "loop=yes" "theme=#FADFA3" "token=tokendemo" %&#125; 将 Blog 分发到不同的库由于某度相当变态的爬虫算法，Github 完全反对某度爬取，所以使用 Github 不得不放弃某度国内庞大的用户，但可以通过将 blog 分发到不同的库，可以同样方便的将自己的 blog 推送到某度。 上篇已经布置了 Github PagesGitee Pages 码云，同样提供免费的 Page 服务，注册后（用户名尽量精简），新建一个与用户名相同的仓库（不区分大小写），这样可以避免二级域名 开启 Pages服务：在仓库目录下，在上方”服务”中开启 “Gitee Pages”，生成网址：https://qixqi.gitee.io 然后到本地博客目录，我的是blog，修改配置文件 123456deploy: type: git repository: - https://github.com/QIXQI/qixqi.github.io.git - https://gitee.com/QIXQI/qixqi.git branch: master 提交 blog 1hexo clean; hexo g; hexo d; 更新 Pages 服务：码云恶心的一点就是提交 blog 后每次需要手动更新Pages 服务，否则访问 https://qixqi.gitee.io 仍是上次提交的blog，亟需解决的问题。 然后访问 https://qixqi.gitee.io ，OK Coding (目前Coding 已经被腾讯云开发者平台包揽) 同样注册账号，创建与用户名一样的仓库 在仓库中左侧”代码”中开启 Pages 服务，生成 https://qixxqi.coding.me 修改本地 blog 配置 12345678deploy: type: git repository: - https://github.com/QIXQI/qixqi.github.io.git - https://gitee.com/QIXQI/qixqi.git - https://git.dev.tencent.com/QIXXQI/qixxqi.git branch: master 提交 blog，Coding与Github一样，提交后无需再更新Pages服务，直接访问 https://qixxqi.coding.me 即可，多刷新几次就可以 在自己的服务器上搭建 blog由于先前自己搭建了一台腾讯云的服务器，学生版，一年才 ¥120，很便宜的； 服务器用 nginx 挂出多个网站 服务器只用来写 blog 未免有些浪费，可以另开一个网站来挂载 blog 由于 80端口已经监听 http, 443端口监听 https，需要新开一个端口来监听 blog网站 访问腾讯云安全组 ，添加入站规则，类型：自定义，来源：0.0.0.0/0，协议端口：TCP: 90，策略：允许 （根据自己惨痛教训，必须要在安全组开启端口） 连接服务器，编辑 /etc/nginx/conf.d/virtual.conf（没有新建） 12345678910server&#123; listen 90; # 新建的端口 root /usr/share/nginx/qixqi; # blog 根目录（与网站根目录类似) server_name: localhost; charset: utf-8; location / &#123; index index.php index.html index.htm; &#125;&#125; 这里只是简单配置一下 blog 的配置，更详细的可以参考网站的配置 最后一步：在服务器配置 git ​ 安装 git: 1yum install git ​ 创建 git 仓库 12345mkdir /home/git/chown -R $USER:$USER /home/git/chmod -R 755 /home/gitcd /home/gitgit init --bare qixqi.git # qixqi 为仓库名，可以自设 ​ 创建一个新的 git 钩子 在 /home/git/qixqi.git/hooks 文件下新建钩子文件 post-receive 12cd /home/git/qixqi.git/hooksvim post-receive 修改 12#!/bin/bashgit --work-tree=/usr/share/nginx/qixqi --git-dir=/home/git/qixqi.git checkout -f ​ 工作原理是，提交时先访问 /home/git/qixqi.git ，然后receive，提交到 blog根. 目录，/usr/share/nginx/qixqi/ 修改本地 blog 的配置文件 12345678deploy: type: git repository: - https://github.com/QIXQI/qixqi.github.io.git - https://gitee.com/QIXQI/qixqi.git - https://git.dev.tencent.com/QIXXQI/qixxqi.git - root@qixqi.club:/home/git/qixqi branch: master 其中 www.qixqi.club 是我新申请的域名，一年才¥1 提交 1hexo clean; hexo g; hexo d 这样提交一次，会同时分发到4个库 到这里为止，就配置好了，当然你可以不用4个都分发，只需要选择Github 和另外一个即可，推荐 Gitee，因为Coding 速度最慢，而服务器最快，但收费啊。 创建 “分类” “标签” “关于” 页面在 blog 站点目录下 123hexo new page "categories"hexo new page "tags"hexo new page "about" 这样就在 blog/source 目录下创建了 “categories”, “tags”, “about” 文件夹，包含的index.md 分别是页面的主页 但这时候还不能在主页菜单中显示 “分类” “标签” “关于”，需要修改主题配置文件，在 blog/themes/next/下修改 _config.yml 1234567menu: home: / || home archives: /archives/ || archive categories: /categories/ || th tags: /tags/ || tags about: /about/ || user #commonweal: /404/ || heartbeat #腾讯404公益页面 那么怎样给创建的博文添加标签并分类呢？ 只需要新建博客的时候，修改 .md 文件头部即可，比如： 12345678910111213---title: #标题author: #作者date: #新建博客的时间tags: #添加多个标签，Hexo与next并行关系 - Hexo - nextcategories: #添加分类，Hexo与next是包含关系 - Hexo - nexttoc: true #生成文章目录description: #描述，首页文章显示的摘要--- 这样就添加了标签与分类 添加社交链接编辑主题配置文件，添加 1234social: Github: https://github.com/用户民 || github E-Mail: mailto:你的邮件 || envelope ... 根据自身需要增减 添加友情链接编辑主题配置文件，添加 1234links_title: 友情链接links: Github: https://www.github.com Telegram: https://www.telegram.org 根据需要增减 设置头像选择好图片后，在 blog 站点下的source 文件夹下，新建 upload 文件夹，在到upload 文件夹下新建 image 文件夹，将图片放到image 文件夹下 然后配置主题配置文件，修改 1avatar: /upload/image/"图像名" 基本设置修改 blog 站点的配置文件，即根目录下的_config.yml 12345title: #标题subtitle: #副标题description: Keep fucking the world #站点描述author: #作者language: zh-Hans 主题设置Next 主题自带4中外观，在主题配置文件中修改 1234scheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 看看自己喜欢哪个😍 阅读更多默认首页的文章会全部显示文章，在.md文件中加入 description 就可以只显示摘要，阅读更多显示全文 1234567891011title: hexo blog 美化升级author: qixqidate: 2019-04-19 20:24:16tags: - Hexocategories: - Hexo - Nexttoc: truedescription: 这篇随笔记录了自己 Github Pages 美化的过程，以及添加一系列的常用功能，持续更新 ... 这样首页只显示摘要，不会显示全文 评论系统valine valine 是免费、简洁、快速、高效、界面友好、轻量易用的评论系统 注册 LeanCloud跟着提示注册即可 创建LeanCloud 应用选择”开发版” 在设置 &gt; 应用Key， 就能看到自己应用的 App ID, App Key了 在设置 &gt; 安全中心 &gt; Web 安全域名 ，添加自己的域名和本地的 localhost:4000 比如我的： 12345678http://localhost:4000https://qixqi.github.iohttps://qixqi.gitee.iohttps://qixxqi.coding.mehttp://qixqi.club:90https://qixqi.club:91http://zhengxiang4056.club:90https://zhengxiang4056.club:91 你的可能没那么多，全添加上就行了，然后保存 修改主题配置文件在 blog/theme/next/ 下，修改主题配置文件，修改 valine 12345678910valine: enable: true appid: #你的App id，最好复制，自己输入出错率高 appkey: #你的App key notify: false verify: false placeholder: ヾﾉ≧∀≦)来啊，快活啊 avatar: mm guest_info: nick, mail, link pageSize: 10 这样就添加了评论系统，快去快去快活吧ヾﾉ≧∀≦) 添加站内搜索功能先安装 hexo-generator-searchdb 插件，在 blog 根目录执行 1npm install hexo-generator-searchdb --save 然后修改站点配置文件，添加代码 12345search: path: search.xml field: post format: html limit: 10000 然后修改主题配置文件，修改 local_search 12local_search: enable: true 然后菜单中就会出现 “搜索” 来实现本地搜索了 顶部加载条在 blog/themes/next/ 下，修改主题配置文件，找到 “pace” 12345678910111213141516171819# Progress bar in the top during page loading.pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 其中 “pace_theme” 是加载条的样式，选择一个就可以了 添加RSS安装插件 1npm install hexo-generator-feed --save 然后修改主题配置文件 1rss: /atom.xml 点击桃心效果1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 首先，在 blog/themes/next/source/js/src/ 下新建 love.js，然后将上面👆的代码copy到love.js 然后修改主题配置文件，添加 love: true 12# 点击爱心love: true 最后，在 blog/themes/next/layout/_layout.swig 文件末尾，body之前引入下面代码 123&#123;% if theme.love %&#125; &lt;script type="text/javascript" src="/js/src/love.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 如果想取消点击桃心效果，可以在主题配置文件中，修改 12# 点击爱心love: false 修改文章内超链接的样式修改 themes/next/source/css/_common/components/post/post.styl，在末尾添加(@import 之前) 12345678910.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 其中 .post-body, p是为了限定 a 的范围，不影响其他如标题的样式 修改文章底部的那个带#号的标签修改 blog/themes/next/layout/_macro/post.swig， 找到这一行： 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 将其修改为： 1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 实现点击爆炸效果首先，在 themes/next/source/js/src/ 下新建 firework.js，复制一下代码: 1"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;"use strict";function updateCoords(e)&#123;pointerX=(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY=e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t=anime.random(0,360)*Math.PI/180,a=anime.random(50,180),n=[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color=colors[anime.random(0,colors.length-1)],a.radius=anime.random(16,32),a.endPos=setParticuleDirection(a),a.draw=function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle=a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a=&#123;&#125;;return a.x=e,a.y=t,a.color="#F00",a.radius=0.1,a.alpha=0.5,a.lineWidth=6,a.draw=function()&#123;ctx.globalAlpha=a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth=a.lineWidth,ctx.strokeStyle=a.color,ctx.stroke(),ctx.globalAlpha=1&#125;,a&#125;function renderParticule(e)&#123;for(var t=0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a=createCircle(e,t),n=[],i=0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:"linear",duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:"easeOutExpo",update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n=this,i=arguments;clearTimeout(a),a=setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl=document.querySelector(".fireworks");if(canvasEl)&#123;var ctx=canvasEl.getContext("2d"),numberOfParticules=30,pointerX=0,pointerY=0,tap="mousedown",colors=["#FF1461","#18FF92","#5A87FF","#FBF38C"],setCanvasSize=debounce(function()&#123;canvasEl.width=2*window.innerWidth,canvasEl.height=2*window.innerHeight,canvasEl.style.width=window.innerWidth+"px",canvasEl.style.height=window.innerHeight+"px",canvasEl.getContext("2d").scale(2,2)&#125;,500),render=anime(&#123;duration:1/0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;"sidebar"!==e.target.id&amp;&amp;"toggle-sidebar"!==e.target.id&amp;&amp;"A"!==e.target.nodeName&amp;&amp;"IMG"!==e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener("resize",setCanvasSize,!1)&#125;; 然后，在主题配置文件中添加： 12# 点击爆炸效果fireworks: true 最后，和点击桃心效果一样，修改 themes/next/layout/_layout.swig, 在 body 之前添加代码: 1234&#123;% if theme.fireworks %&#125; &lt;canvas class="fireworks" style="position: fixed; left: 0; top: 0; z-index: 1; pointer-events: none;"&gt;&lt;/canvas&gt; &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt;&#123;% endif %&#125; 同样，想要取消点击爆炸效果时，在主题配置文件中修改 12# 点击爆炸效果fireworks: false 实现打赏功能首先，要有 微信和支付宝的收款二维码，放到 blog/source/upload/image/ 下 然后，在配置配置文件中，修改 “Reward” 12345# Rewardreward_comment: 小礼物走一走wechatpay: /upload/image/wechatpay.jpegalipay: /upload/image/alipay.png#bitcoin: /images/bitcoin.png 其中 “wechatpay.jpeg”， “alipay.png” 修改为你自己的图像名就可以了 实现打赏字体只闪动三次修改文件 blog/themes/next/source/css/_common/components/post/post-reward.styl 找到 “#wechat”, “#alipay”，修改如下 12345678910#wechat:hover p&#123; animation: roll 0.1s 3 linear; -webkit-animation: roll 0.1s 3 linear; -moz-animation: roll 0.1s 3 linear;&#125;#alipay:hover p&#123; animation: roll 0.1s 3 linear; -webkit-animation: roll 0.1s 3 linear; -moz-animation: roll 0.1s 3 linear;&#125; 修改favicon图标首先要有一个 32 × 32 的图标(.ico, .png 都可以)，放到 blog/source/upload/image文件夹下 然后，在主题配置文件中，定位到 “favicon”，只修改 medium 即可 123456small: /images/favicon-16×16-next.pngmedium: /upload/image/图标名apple_touch_icon: /images/apple-touch-icon-next.pngsafari_pinned_tab: /images/logo.svg#android_manifest: /images/manifest.json#ms_browserconfig: /images/browserconfig.xml 为博客加入动态背景首先，在 blog/themes/source/js/src/ 下新建文件 particle.js，copy 以下代码： 1!function()&#123;function n(n,e,t)&#123;return n.getAttribute(e)||t&#125;function e(n)&#123;return document.getElementsByTagName(n)&#125;function t()&#123;var t=e("script"),o=t.length,i=t[o-1];return&#123;l:o,z:n(i,"zIndex",-1),o:n(i,"opacity",.5),c:n(i,"color","0,0,0"),n:n(i,"count",99)&#125;&#125;function o()&#123;c=u.width=window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,a=u.height=window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight&#125;function i()&#123;l.clearRect(0,0,c,a);var n,e,t,o,u,d,x=[w].concat(y);y.forEach(function(i)&#123;for(i.x+=i.xa,i.y+=i.ya,i.xa*=i.x&gt;c||i.x&lt;0?-1:1,i.ya*=i.y&gt;a||i.y&lt;0?-1:1,l.fillRect(i.x-.5,i.y-.5,1,1),e=0;e&lt;x.length;e++)n=x[e],i!==n&amp;&amp;null!==n.x&amp;&amp;null!==n.y&amp;&amp;(o=i.x-n.x,u=i.y-n.y,d=o*o+u*u,d&lt;n.max&amp;&amp;(n===w&amp;&amp;d&gt;=n.max/2&amp;&amp;(i.x-=.03*o,i.y-=.03*u),t=(n.max-d)/n.max,l.beginPath(),l.lineWidth=t/2,l.strokeStyle="rgba("+m.c+","+(t+.2)+")",l.moveTo(i.x,i.y),l.lineTo(n.x,n.y),l.stroke()));x.splice(x.indexOf(i),1)&#125;),r(i)&#125;var c,a,u=document.createElement("canvas"),m=t(),d="c_n"+m.l,l=u.getContext("2d"),r=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.oRequestAnimationFrame||window.msRequestAnimationFrame||function(n)&#123;window.setTimeout(n,1e3/45)&#125;,x=Math.random,w=&#123;x:null,y:null,max:2e4&#125;;u.id=d,u.style.cssText="position:fixed;top:0;left:0;z-index:"+m.z+";opacity:"+m.o,e("body")[0].appendChild(u),o(),window.onresize=o,window.onmousemove=function(n)&#123;n=n||window.event,w.x=n.clientX,w.y=n.clientY&#125;,window.onmouseout=function()&#123;w.x=null,w.y=null&#125;;for(var y=[],s=0;m.n&gt;s;s++)&#123;var f=x()*c,h=x()*a,g=2*x()-1,p=2*x()-1;y.push(&#123;x:f,y:h,xa:g,ya:p,max:6e3&#125;)&#125;setTimeout(function()&#123;i()&#125;,100)&#125;(); 然后，找到 blog/themes/next/layout/_layout.swig，在末尾，body 之前 加上下列代码： 这里给出两种样式： 默认灰色线条 1&lt;script type="text/javascript" src="/js/src/particle.js"&gt;&lt;/script&gt; 浅蓝色线条 1&lt;script type="text/javascript" src="/js/src/particle.js" count="50" zindex="-2" opacity="1" color="0, 104, 183"&gt;&lt;/script&gt; 当然你也可以自定义自己喜欢的样式😍 为项目主页添加 README.md项目需要添加 README.md 说明文件，由于 .md 文件解析时会被自动生成 html 网页，所以解析时需要跳过 README.md 首先，把 “README.md” 文件放到 blog/source/ 目录下 然后，在站点配置文件中，搜索 “skip_render”，添加 1skip_render: README.md 这样 “hexo g”生成时就会跳过”README.md” 文章结束语首先，在 themes/next/layout/_macro 中新建 passage-end-tag.swig，添加： 1234567&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align: center; color: #ccc; font-size: 14px;"&gt; ----------本文结束&lt;i class="fa fa-paw"&gt;&lt;/i&gt;感谢您的阅读---------- &lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后，在 themes/next/layout/_macro/post.swig 文件中，找到 123&#123;#####################&#125;&#123;### END POST BODY ###&#125;&#123;#####################&#125; 在上面代码👆之前添加 12345&lt;div&gt; &#123;% if not is_index and theme.passage_end_tag: %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 最后，在主题配置文件中添加 12# 文章末尾添加标记passage_end_tag: true 将 passage_end_tag 设置为 false ，就不显示了 添加 fork me on github复制代码Form me on Github 彩带的默认样式 12345678&lt;a href="https://github.com/you"&gt; &lt;img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/567c3a48d796e2fc0 6ea80409cc9dd82bf714434/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769 746875622f726962626f6e732f666f726b6d655f6c6566745f6461726b626c75655f3132313632 312e706e67" alt="Fork me on GitHub" data-canonical- src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png"&gt;&lt;/a&gt; 目前，彩带网站凉了 Github corners 的默认样式 1&lt;a href="https://your-url" class="github-corner" aria-label="View source on GitHub"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; 点击这里获取更多样式 粘贴代码在 blog/themes/next/layout/_layout.swig 文件中找到 class=”headband” ，添加代码 123456&lt;div class="headband"&gt;&lt;/div&gt; &lt;header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"&gt; &lt;a href="https://github.com/QIXQI" class="github-corner" aria-label="View source on GitHub"&gt;&lt;svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"&gt;&lt;path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"&gt;&lt;/path&gt;&lt;path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"&gt;&lt;/path&gt;&lt;path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; &lt;div class="header-inner"&gt; &#123;%- include '_partials/header.swig' %&#125; &lt;/div&gt; &lt;/header&gt; 将 a 元素的 href 改为你自己的github 地址，如 https://github.com/QIXQI Perfect…装逼格调从此高大上 浏览文章时显示浏览进度修改主题配置文件 12# Scroll percent label in b2t buttonscrollpercent: true 添加不蒜子站点统计编辑主题配置文件 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class="fa fa-user"&gt;&lt;/i&gt; 访客数 site_uv_footer: 人 #custom pv span for the whole site site_pv: true site_pv_header: &lt;i class="fa fa-eye"&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 #custom pv span for one page only page_pv: true page_pv_header: &lt;i class="fa fa-file-o"&gt;&lt;/i&gt; 阅读次数 page_pv_footer: 其中，enable 是整个 busuanzi 统计系统的开关 site_uv 统计整个站点的访客数 site_pv 统计整个站点的访问量 page_pv 统计单页面的阅读次数 但是，由于busuanzi 作者的域名被收回，还需要重新设置域名 在 blog/themes/next/layout/_third-party/analytics 下，修改 busuanzi-counter.swig 1234找到如下代码&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;修改为：&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; 这样就可以了 添加 ShareSDK 分享多说分享凉了，也不太喜欢主题提供的分享，爬到博主Magicer的ShareSDK分享，还不错 注册 ShareSDK简单填写信息注册后，可以先不实名注册，添加应用，生成 appid 和 appkey 然后在左边👈 添加 ShareSDK，就可以了 创建 sharesdk.swig在 blog/themes/next/layout/_partials/share/ 文件夹下，创建sharesdk.swig，添加一下代码 12345678910111213141516171819&lt;!--MOB SHARE BEGIN--&gt;&lt;div class="-mob-share-ui-button -mob-share-open"&gt;分享&lt;/div&gt;&lt;div class="-mob-share-ui" style="display: none"&gt; &lt;ul class="-mob-share-list"&gt; &lt;li class="-mob-share-weibo"&gt;&lt;p&gt;新浪微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-tencentweibo"&gt;&lt;p&gt;腾讯微博&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qzone"&gt;&lt;p&gt;QQ空间&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-qq"&gt;&lt;p&gt;QQ好友&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-renren"&gt;&lt;p&gt;人人网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-kaixin"&gt;&lt;p&gt;开心网&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-douban"&gt;&lt;p&gt;豆瓣&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-facebook"&gt;&lt;p&gt;Facebook&lt;/p&gt;&lt;/li&gt; &lt;li class="-mob-share-twitter"&gt;&lt;p&gt;Twitter&lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="-mob-share-close"&gt;取消&lt;/div&gt;&lt;/div&gt;&lt;div class="-mob-share-ui-bg"&gt;&lt;/div&gt;&lt;script id="-mob-share" src="https://f1.webshare.mob.com/code/mob-share.js?appkey=&#123;&#123;theme.shareSDKappkey&#125;&#125;"&gt;&lt;/script&gt;&lt;!--MOB SHARE END--&gt; 添加可选配置在 blog/themes/blog/layout/post.swig中，修改一下部分 12345678910111213&lt;div class="post-spread"&gt; &#123;% if theme.jiathis %&#125; &#123;% include '_partials/share/jiathis.swig' %&#125; &#123;% elseif theme.baidushare %&#125; &#123;% include '_partials/share/baidushare.swig' %&#125; &#123;% elseif theme.add_this_id %&#125; &#123;% include '_partials/share/add-this.swig' %&#125; &#123;% elseif theme.duoshuo_shortname and theme.duoshuo_share %&#125; &#123;% include '_partials/share/duoshuo_share.swig' %&#125; &#123;% elseif theme.sharesdk %&#125; &#123;% include '_partials/share/sharesdk.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 修改主题配置文件在主题配置文件中添加 123# Sharesdksharesdk: trueshareSDKappkey: 你的appkey 这样不想使用时，改为 sharesdk: false 就可以了 添加字数统计、阅读时长安装插件站点根目录下执行 1npm install hexo-wordcount --save 有提示说 Node版本 7.6.0 之前，请安装 2.x 版本，不过我没遇到这个 bug，那就放在这里Warning 一下吧 1npm install hexo-wordcount@2 --save 修改主题配置文件在 主题 配置文件下修改 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true # 单篇 字数统计 min2read: true # 单篇 阅读时长 totalcount: true # 网站 字数统计 separated_meta: true 修改显示文字其实，到这里已经配好了，这部分知识修改显示的文字 在 blog/themes/next/layout/_macro/post.swig 文件中，找到 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125;&lt;/span&gt; 然后修改，加上单位字 123&lt;span title="&#123;&#123; __('post.wordcount') &#125;&#125;"&gt; &#123;&#123; wordcount(post.content) &#125;&#125; 字&lt;/span&gt; 同样的，可以修改 “阅读时长”，加上单位分钟 123&lt;span title="&#123;&#123; __('post.min2read') &#125;&#125;"&gt; &#123;&#123; min2read(post.content) &#125;&#125; 分钟&lt;/span&gt; 修改作者头像为可以旋转的圆形在 blog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl 文件末尾添加 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 隐藏网页底部 强力驱动与主题打开主题配置文件，修改 12# Hexo link (Powered by Hexo)powered: false 12345theme: # Theme &amp; scheme info link (Theme - NexT.scheme). enable: false # Version info of NexT after scheme info (vX.X.X). version: true 修改网页底部桃心变星星✨在 blog/themes/next/layout/_partials/footer.swig 中 找到 “with-love”，修改 123&lt;span class="with-love"&gt; &lt;i class="fa fa-star"&gt;&lt;/i&gt;&lt;/span&gt; 当然，可以在 图标库 选择自己喜欢的图标 插入音频方式一：html由于 .md 文件可以方便的导入 html 代码，所以 html 引入音乐的方式可以考虑 有两种方式，一个是 flash，另一个是 html5，由于 flash 逐渐被淘汰，而且ios移动端不支持 flash ，这里只介绍 html5 方式 在 博客.md 文件中插入 audio 元素 12345&lt;audio src="https://qixqi.club/audio/homeway.mp3" controls none&gt; &lt;p&gt; This browser does not support our audio format. &lt;/p&gt;&lt;/audio&gt; 效果如下： This browser does not support our audio format. 方式二：网易云音乐的外链 最后不要自动播放，一个是好多浏览器对自动播放不太友好，二是对用户也不太友好 然后在 博客.md 文件中插入 iframe 元素 1&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&amp;id=28267530&amp;auto=0&amp;height=66"&gt;&lt;/iframe&gt; 效果如下： 方式三：借助插件在站点根目录下 1npm install hexo-tag-aplayer --save 在 博客 .md 文件中插入 1&#123;% aplayer "南方姑娘" "赵雷" "https://qixqi.club/audio/southern-girl.mp3" "https://qixqi.club/images/southern-girl.jpg" "autoplay=false" %&#125; 同样最好不要自动播放，同时 “autoplay=false”报错：Unrecognized tag argument，所以删去后效果如下 var ap = new APlayer({ element: document.getElementById("aplayer-vbLzxASH"), narrow: false, autoplay: false, showlrc: false, music: { title: "南方姑娘", author: "赵雷", url: "https://qixqi.club/audio/southern-girl.mp3", pic: "https://qixqi.club/images/southern-girl.jpg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 插入视频方式一：htmlhtml 同样有两种方式插入视频， flash, html5，这里只介绍 html5方式 在博客 .md 文件中插入 video 元素 123&lt;video src="https://qixqi.club/video/puppy.mp4" width="400" height="300" poster="https://qixqi.club/images/puppy.png" preload="metadata" controls&gt; &lt;p&gt;浏览器不支持&lt;/p&gt;&lt;/video&gt; 效果如下 浏览器不支持 方式二：bilibili 的 外链在博客 .md 文件中插入 iframe 元素 1&lt;iframe src="//player.bilibili.com/player.html?aid=49966170&amp;cid=87480266&amp;page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"&gt; &lt;/iframe&gt; 方式三：借助插件在 站点 根目录下，执行 1npm install hexo-tag-dplayer --save 在博客 .md 文件中插入 video 元素 1&#123;% dplayer "url=https://qixqi.club/video/puppy.mp4" "pic=https://qixqi.club/images/puppy.png" "loop=yes" "theme=#FADFA3" "autoplay=false" "token=tokendemo" %&#125; 同样不自动播放，但奇怪的是”autoplay=false”不报错，那就不删除了 效果如下： (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"https://qixqi.club/video/puppy.mp4","pic":"https://qixqi.club/images/puppy.png"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})() 添加看板娘在站点根目录下，执行 1npm install hexo-helper-live2d --save 然后在 &lt;主题&gt; 配置文件下，添加 12345678910111213141516171819# 看板娘live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: use: live2d-widget-model-wanko display: position: right width: 150 height: 300 mobile: show: true react: opacity: 0.7 目前暂时不能通过 enable: false 来取消看板娘效果，但可以通过可以卸载扩展 在站点根目录下 1npm install hexo-helper-live2d --save 通过插件安装的看板娘是个哑巴，不能看她换衣服，十分不爽，该考试了，下次再仔细研究看板娘的穿衣打扮，目前养个漂亮的小哑巴还是不错的。 未完待续。。。 提交百度和Google收录生成站点地图12npm install hexo-generator-baidu-sitemap --savenpm install hexo-generator-sitemap --save 修改配置文件修改主题与站点配置文件均可，添加 12345# 自动生成 sitemapsitemap: path: sitemap.xml # Googlebaidusitemap: path: baidusitemap.xml # 百度 提交给Google关于如何使用Google，相信你们都有办法，资金充足的话可以自建服务器来科学浏览网页vultr，有详细的教程，如果不想破费的话，可以留言，留下联系方式，我会分享自己知道的方法。 登陆 Google站长]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Manjaro/MacOS 搭建 Github Pages 个人博客]]></title>
    <url>%2F2019%2F04%2F15%2Fhexo%2F</url>
    <content type="text"><![CDATA[这篇主要是小白记录新建 Github Pages 的过程，大佬手下留情 :-D 有疑问可以交流的啊 Github 配置本地 Hexo:安装 Ｎode.jsManjaro 利用 nvm 安装 Node.js 1wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装 nvm 后安装 Node.js 1nvm install stable MacOS 利用 Homebrew 安装 Node.js 1curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1 安装 brew 后安装 Node.js 1brew install node 安装gitManjaro 似乎默认已经安装， 1sudo pacman -S git MacOS 1brew install git 全局安装 HexoManjaro 1sudo npm install -g hexo MacOS 1npm install -g hexo 创建blog文件1hexo init blog 安装12cd blognpm install 启动 Hexo1hexo s 替换为next主题在 blog 目录下 1git clone https://github.com/iissnan/hexo-theme-next themes/next 修改 blog 目录下的 _config.yml 文件 1vim _config.yml 将 theme: landscape 替换为 theme: next 启动 hexo 服务器在 blog 目录下 123hexo cleanhexo ghexo s 在执行完上面三条命令后，终端中显示 http://localhost:4000 ，在浏览器中输入 http://localhost:4000 ，就会看到本地 hexo 服务器已经配置成功 效果图 开启 MathJax在 blog 目录下 1vim ./themes/next/_config.yml 找到 mathjax 修改为 mathjax: ​ enable: true Github Pages 配置hexo 在本地已经配置好本地服务器，接下来需要在github上创建 repository 选择New repository选择repository namerepository name 一般设置为 “username.github.io”, 其中”username” 一般是你的github 用户名， 选择库名后，在页面底端勾选”Initialize this repository with a README “; 创建成功后就可以在浏览器中使用 https://用户名.github.io 来访问 将本地配置的 blog 提交到 Github PagesClone repository1git clone https://github.com/username/username.github.io 生成 index.html12cd username.github.ioecho "Hello World" &gt; index.html 推送本地文件到 Github Pages12345git add --allgit commit -m "Initial commit"git config --global user.name "github用户名"git config --global user.email github邮箱git push -u origin master 如果输入 “git push -u origin master” 后邮箱报错，可以到 https://github.com 的 “Setting” 中的 “Email” 取消勾选 “Keep my email address private” 同步本地的 hexo 博客到 github 上安装一个扩展在 blog 目录下 1sudo npm install hexo-deployer-git --save 配置_config.yml修改添加 1234deploy:type: gitrepository: https://github.com/username/username.github.io.gitbranch: master 清除缓存上传 hexo 到 Github Pages123hexo cleanhexo ghexo d 这时候在浏览器中输入 https://用户名.github.io 就可以访问博客了 美化：更换 themeCyanStyle 是 Wordpress 的 Twentytwelve 主题在 Hexo 上的迁移，清新简约，个人感觉良好 clone hexo-theme-cyanstyle在 blog 目录下 1git clone https://github.com/wizardforcel/hexo-theme-cyanstyle themes/cyanstyle 修改 _config.yml在 blog 目录下， 修改 _config.yml 中的 theme 为 theme: cyanstyle 本地预览在 blog 目录下 123hexo cleanhexo ghexo s 个人觉得挺好看的 提交到 Github Repositories在 blog 目录下 123hexo cleanhexo ghexo d 浏览器浏览 新建博文主要解决在 hexo 博客中插入图片路径问题 修改_config.yml在 blog 目录下修改 _config.yml 配置文件中的 post_asset_folder: true 此时在新建博客的时候会自动创建一个文件夹 安装一个扩展在 blog 目录下执行 1npm install https://github.com/CodeFalling/hexo-asset-image --save 创建博客在 blog 目录下执行 1hexo new "博客名" 之后会在 blog/source/_post/下出现 “博客名.md” 和 “博客名”文件夹 编写 .md 文件编写 blog/source/_post/“博客名.md” markdown 是一种标记语言，网上教程太多，这里不再赘述了 O(∩_∩)O~~ 在 .md 文件中插入图片先将图片文件放到 /blog/source/_post/“博客名” 文件夹下 然后在 .md 文件中 插入 1![aratar](图像名) 输入图像名的时候不能有路径，只需要图像名和后缀即可，比如 “cyanstyle.png” 注意：不要通过 “选择本地文件” 方式插入图片，这种方式插入图片时是绝对路径 本地预览在 blog 目录下执行 123hexo cleanhexo ghexo s 浏览器访问 http://localhost:4000 提交到 Github Repositories在 blog 目录下执行 123hexo cleanhexo ghexo d 浏览器访问 https://用户名.github.io 参考：https://www.jianshu.com/p/e49eeafe506e 参考：https://www.jianshu.com/p/c2ba9533088a 参考：https://www.jianshu.com/p/cf0628478a4e]]></content>
      <categories>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
